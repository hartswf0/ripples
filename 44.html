<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RIPPLES // PURE CANVAS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>
        // =========================================
        // RIPPLES ENGINE (Inline)
        // =========================================
        class RipplesEngine {
            constructor(config = {}) {
                this.latentLibrary = config.latentLibrary || {};
                this._listeners = new Map();
                this.state = { scenario: null, selectedEntity: null, tick: 0, worldtext: null, lastRipple: null };
            }

            on(event, cb) { if (!this._listeners.has(event)) this._listeners.set(event, []); this._listeners.get(event).push(cb); }
            emit(event, data = {}) {
                this._listeners.get(event)?.forEach(cb => cb(data));
                if (event !== 'state:change') this._listeners.get('state:change')?.forEach(cb => cb({ state: this.getState(), event, data }));
            }

            getState() { return { ...this.state }; }
            getScenario() { return this.latentLibrary[this.state.scenario] || null; }
            getEntities() { return this.getScenario()?.entities || []; }
            getEntity(id) { return this.getEntities().find(e => e.id === id); }
            getScenarioIds() { return Object.keys(this.latentLibrary); }

            loadScenario(id) {
                if (!this.latentLibrary[id]) return;
                this.state.scenario = id;
                this.state.selectedEntity = null;
                this.state.worldtext = null;
                this.emit('scenario:change', { scenario: this.getScenario() });
            }

            selectEntity(id) { this.state.selectedEntity = id; this.emit('entity:select', { entity: this.getEntity(id) }); }
            deselectEntity() { this.state.selectedEntity = null; this.emit('entity:deselect', {}); }

            getLatent(entityId, vector) {
                return this.getScenario()?.latent?.[entityId]?.[vector] || `${this.getEntity(entityId)?.name} responds to ${vector}...`;
            }

            triggerVector(vector) {
                if (!this.state.selectedEntity) return null;
                const entity = this.getEntity(this.state.selectedEntity);
                this.state.tick++;
                const worldtext = this.getLatent(this.state.selectedEntity, vector);
                const ripple = { tick: this.state.tick, entity, vector, worldtext };
                this.state.worldtext = worldtext;
                this.state.lastRipple = ripple;
                this.emit('ripple:complete', ripple);
                return ripple;
            }

            cycleScenario() {
                const ids = this.getScenarioIds();
                const idx = ids.indexOf(this.state.scenario);
                const next = ids[(idx + 1) % ids.length];
                this.loadScenario(next);
            }
        }

        // =========================================
        // LATENT LIBRARY
        // =========================================
        const LATENT_LIBRARY = {
            cupboard: {
                id: "cupboard", name: "The Cupboard", ambient: [20, 15, 25],
                entities: [
                    { id: "ant-scout", name: "Ant Scout", symbol: "A", color: [74, 246, 38] },
                    { id: "dust-mote", name: "Dust Mote", symbol: "D", color: [136, 136, 136] },
                    { id: "light-beam", name: "Light Beam", symbol: "L", color: [255, 221, 0] },
                    { id: "spider", name: "Spider", symbol: "S", color: [170, 68, 68] },
                    { id: "plate-stack", name: "Plates", symbol: "P", color: [102, 136, 170] },
                    { id: "draft", name: "Draft", symbol: "~", color: [68, 170, 255] }
                ],
                latent: {
                    "ant-scout": { GOAL: "Pheromone trace detected. Antennae sweep for sugar.", OBSTACLE: "Ceramic cliff. Recalculating route.", SHIFT: "Role shift: forager → guard." },
                    "dust-mote": { GOAL: "Thermal current pulls toward light.", OBSTACLE: "Static pins to glass.", SHIFT: "Aggregating with others." },
                    "light-beam": { GOAL: "Seeking surface. Bouncing deeper.", OBSTACLE: "Edge cuts stream. Fragmenting.", SHIFT: "Dawn rotation. Path shifts." },
                    "spider": { GOAL: "Vibration. Calibrating for prey.", OBSTACLE: "Web torn. Assessing damage.", SHIFT: "Cold. Metabolism slowing." },
                    "plate-stack": { GOAL: "Settling. Seeking equilibrium.", OBSTACLE: "Vibration threatens balance.", SHIFT: "Plate removed. New stability." },
                    "draft": { GOAL: "Threading gaps. Seeking equilibrium.", OBSTACLE: "Door sealed. Dispersing.", SHIFT: "Temperature inverts." }
                }
            },
            forest: {
                id: "forest", name: "Deep Forest", ambient: [10, 25, 15],
                entities: [
                    { id: "mycelium", name: "Mycelium", symbol: "M", color: [255, 255, 255] },
                    { id: "fox", name: "Fox", symbol: "F", color: [255, 136, 68] },
                    { id: "dewdrop", name: "Dew Drop", symbol: "O", color: [136, 204, 255] },
                    { id: "moonlight", name: "Moonlight", symbol: "*", color: [204, 204, 255] },
                    { id: "oak", name: "Oak", symbol: "T", color: [34, 136, 68] },
                    { id: "mushroom", name: "Mushroom", symbol: "m", color: [204, 102, 68] }
                ],
                latent: {
                    "mycelium": { GOAL: "Network extends. Seeking roots.", OBSTACLE: "Dry patch. Retreating.", SHIFT: "Fruiting triggered." },
                    "fox": { GOAL: "Tracking voles. Ears rotating.", OBSTACLE: "Human scent detected.", SHIFT: "Territory adapting." },
                    "dewdrop": { GOAL: "Swelling. Gathering humidity.", OBSTACLE: "Surface tension holds.", SHIFT: "Freezing into ice." },
                    "moonlight": { GOAL: "Filtering through canopy.", OBSTACLE: "Clouds massing.", SHIFT: "Phase advancing." },
                    "oak": { GOAL: "Reaching. Growing rings.", OBSTACLE: "Fungal probe. Defending.", SHIFT: "Autumn withdrawal." },
                    "mushroom": { GOAL: "Pushing upward. Unfurling.", OBSTACLE: "Slug damage. Tolerating.", SHIFT: "Spores ready." }
                }
            },
            void: {
                id: "void", name: "Sector Void Zero", ambient: [5, 5, 15],
                entities: [
                    { id: "satellite", name: "Satellite", symbol: "@", color: [136, 170, 204] },
                    { id: "asteroid", name: "Asteroid", symbol: "#", color: [170, 136, 102] },
                    { id: "nebula-gas", name: "Nebula", symbol: "%", color: [255, 102, 170] },
                    { id: "solar-flare", name: "Solar Flare", symbol: "!", color: [255, 170, 0] },
                    { id: "space-junk", name: "Debris", symbol: "x", color: [102, 102, 102] },
                    { id: "gravity-well", name: "Gravity Well", symbol: "0", color: [68, 68, 255] }
                ],
                latent: {
                    "satellite": { GOAL: "Orbit maintained. Tracking sun.", OBSTACLE: "Debris field. Avoiding.", SHIFT: "Software updating." },
                    "asteroid": { GOAL: "Ancient path. Inertia.", OBSTACLE: "Gravitational bend.", SHIFT: "Thermal fracture." },
                    "nebula-gas": { GOAL: "Drifting to density.", OBSTACLE: "Stellar wind scatters.", SHIFT: "Ionizing. New colors." },
                    "solar-flare": { GOAL: "Erupting. Plasma arc.", OBSTACLE: "Field snaps back.", SHIFT: "Polarity inverts." },
                    "space-junk": { GOAL: "Tumbling. Reflecting.", OBSTACLE: "Impact. Fragmenting.", SHIFT: "Atmosphere grazes." },
                    "gravity-well": { GOAL: "Deepening. Mass accumulates.", OBSTACLE: "Nearby mass disrupts.", SHIFT: "Mass ejection." }
                }
            }
        };

        // =========================================
        // IMMEDIATE MODE RENDERER
        // =========================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const engine = new RipplesEngine({ latentLibrary: LATENT_LIBRARY });

        // State
        let entities = [];
        let ripples = [];
        let textFlash = { text: '', alpha: 0 };
        let scenarioAmbient = [0, 0, 0];

        // Layout
        const UI = {
            margin: 20,
            entitySize: 40,
            vectorSize: 50
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            layoutEntities();
        }

        function layoutEntities() {
            const list = engine.getEntities();
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.min(cx, cy) * 0.5;

            entities = list.map((e, i) => {
                const angle = (i / list.length) * Math.PI * 2 - Math.PI / 2;
                return {
                    ...e,
                    x: cx + Math.cos(angle) * radius,
                    y: cy + Math.sin(angle) * radius,
                    angle,
                    radius: UI.entitySize,
                    hover: false,
                    selected: false,
                    pulse: Math.random() * Math.PI * 2
                };
            });
        }

        function getVectorButtons() {
            const y = canvas.height - UI.margin - UI.vectorSize / 2;
            const spacing = UI.vectorSize + 20;
            const startX = canvas.width / 2 - spacing;

            return [
                { id: 'GOAL', x: startX, y, color: [245, 158, 11], label: '→' },
                { id: 'OBSTACLE', x: startX + spacing, y, color: [239, 68, 68], label: '■' },
                { id: 'SHIFT', x: startX + spacing * 2, y, color: [168, 85, 247], label: '↻' }
            ];
        }

        function getScenarioButton() {
            return { x: canvas.width - UI.margin - 60, y: UI.margin + 12, w: 120, h: 24 };
        }

        // Input handling
        let mouse = { x: 0, y: 0 };

        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            const x = e.clientX;
            const y = e.clientY;

            // Check scenario button
            const sb = getScenarioButton();
            if (x > sb.x && x < sb.x + sb.w && y > sb.y - sb.h / 2 && y < sb.y + sb.h / 2) {
                engine.cycleScenario();
                return;
            }

            // Check entities
            for (const ent of entities) {
                const dx = x - ent.x;
                const dy = y - ent.y;
                if (dx * dx + dy * dy < ent.radius * ent.radius) {
                    if (ent.selected) {
                        engine.deselectEntity();
                    } else {
                        engine.selectEntity(ent.id);
                    }
                    return;
                }
            }

            // Check vector buttons
            const state = engine.getState();
            if (state.selectedEntity) {
                for (const btn of getVectorButtons()) {
                    const dx = x - btn.x;
                    const dy = y - btn.y;
                    if (dx * dx + dy * dy < (UI.vectorSize / 2) * (UI.vectorSize / 2)) {
                        engine.triggerVector(btn.id);
                        return;
                    }
                }
            }
        });

        // Engine events
        engine.on('scenario:change', () => {
            const scenario = engine.getScenario();
            scenarioAmbient = scenario?.ambient || [0, 0, 0];
            layoutEntities();
        });

        engine.on('entity:select', ({ entity }) => {
            entities.forEach(e => e.selected = e.id === entity.id);
        });

        engine.on('entity:deselect', () => {
            entities.forEach(e => e.selected = false);
        });

        engine.on('ripple:complete', ({ entity, vector, worldtext }) => {
            const ent = entities.find(e => e.id === entity.id);
            if (ent) {
                const colors = { GOAL: [245, 158, 11], OBSTACLE: [239, 68, 68], SHIFT: [168, 85, 247] };
                ripples.push({
                    x: ent.x,
                    y: ent.y,
                    radius: 0,
                    maxRadius: 200,
                    color: colors[vector] || [255, 255, 255],
                    alpha: 1
                });
            }
            textFlash = { text: worldtext, alpha: 1 };
        });

        // Animation loop
        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const state = engine.getState();

            // Background with ambient tint
            ctx.fillStyle = `rgb(${scenarioAmbient[0]}, ${scenarioAmbient[1]}, ${scenarioAmbient[2]})`;
            ctx.fillRect(0, 0, w, h);

            // Grid background
            ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < w; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = 0; y < h; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Draw ripples
            ripples = ripples.filter(r => {
                r.radius += 4;
                r.alpha = 1 - (r.radius / r.maxRadius);
                if (r.alpha <= 0) return false;

                ctx.strokeStyle = `rgba(${r.color[0]}, ${r.color[1]}, ${r.color[2]}, ${r.alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                ctx.stroke();
                return true;
            });

            // Draw connections
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < entities.length; i++) {
                for (let j = i + 1; j < entities.length; j++) {
                    ctx.beginPath();
                    ctx.moveTo(entities[i].x, entities[i].y);
                    ctx.lineTo(entities[j].x, entities[j].y);
                    ctx.stroke();
                }
            }

            // Draw entities
            for (const ent of entities) {
                ent.pulse += 0.05;
                const isHover = Math.hypot(mouse.x - ent.x, mouse.y - ent.y) < ent.radius;
                const pulseScale = ent.selected ? 1 + Math.sin(ent.pulse) * 0.1 : 1;
                const r = ent.radius * pulseScale;

                // Outer ring
                ctx.strokeStyle = `rgba(${ent.color[0]}, ${ent.color[1]}, ${ent.color[2]}, ${ent.selected ? 1 : isHover ? 0.6 : 0.3})`;
                ctx.lineWidth = ent.selected ? 3 : 2;
                ctx.beginPath();
                ctx.arc(ent.x, ent.y, r, 0, Math.PI * 2);
                ctx.stroke();

                // Fill
                ctx.fillStyle = `rgba(${ent.color[0]}, ${ent.color[1]}, ${ent.color[2]}, 0.1)`;
                ctx.fill();

                // Symbol
                ctx.fillStyle = `rgb(${ent.color[0]}, ${ent.color[1]}, ${ent.color[2]})`;
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ent.symbol, ent.x, ent.y);

                // Name
                ctx.fillStyle = '#666';
                ctx.font = '10px Courier New';
                ctx.fillText(ent.name, ent.x, ent.y + r + 15);
            }

            // Draw vector buttons
            if (state.selectedEntity) {
                for (const btn of getVectorButtons()) {
                    const isHover = Math.hypot(mouse.x - btn.x, mouse.y - btn.y) < UI.vectorSize / 2;

                    ctx.strokeStyle = `rgb(${btn.color[0]}, ${btn.color[1]}, ${btn.color[2]})`;
                    ctx.lineWidth = isHover ? 3 : 2;
                    ctx.beginPath();
                    ctx.arc(btn.x, btn.y, UI.vectorSize / 2, 0, Math.PI * 2);
                    ctx.stroke();

                    if (isHover) {
                        ctx.fillStyle = `rgba(${btn.color[0]}, ${btn.color[1]}, ${btn.color[2]}, 0.2)`;
                        ctx.fill();
                    }

                    ctx.fillStyle = `rgb(${btn.color[0]}, ${btn.color[1]}, ${btn.color[2]})`;
                    ctx.font = 'bold 20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(btn.label, btn.x, btn.y);

                    ctx.font = '9px Courier New';
                    ctx.fillText(btn.id, btn.x, btn.y + UI.vectorSize / 2 + 12);
                }
            }

            // Draw worldtext flash
            if (textFlash.alpha > 0) {
                textFlash.alpha -= 0.005;
                ctx.fillStyle = `rgba(200, 200, 200, ${textFlash.alpha})`;
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Word wrap
                const words = textFlash.text.split(' ');
                const lines = [];
                let line = '';
                const maxWidth = w * 0.6;

                for (const word of words) {
                    const test = line + word + ' ';
                    if (ctx.measureText(test).width > maxWidth) {
                        lines.push(line);
                        line = word + ' ';
                    } else {
                        line = test;
                    }
                }
                lines.push(line);

                const lineHeight = 20;
                const startY = h / 2 - (lines.length * lineHeight) / 2;
                lines.forEach((l, i) => {
                    ctx.fillText(l.trim(), w / 2, startY + i * lineHeight);
                });
            }

            // Draw HUD
            ctx.fillStyle = '#444';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`SCENARIO: ${engine.getScenario()?.name || 'NONE'}`, UI.margin, UI.margin + 12);
            ctx.fillText(`TICK: ${state.tick}`, UI.margin, UI.margin + 26);
            ctx.fillText(`ENTITIES: ${entities.length}`, UI.margin, UI.margin + 40);

            // Scenario button
            const sb = getScenarioButton();
            const sbHover = mouse.x > sb.x && mouse.x < sb.x + sb.w && mouse.y > sb.y - sb.h / 2 && mouse.y < sb.y + sb.h / 2;
            ctx.strokeStyle = sbHover ? '#888' : '#444';
            ctx.lineWidth = 1;
            ctx.strokeRect(sb.x, sb.y - sb.h / 2, sb.w, sb.h);
            ctx.fillStyle = sbHover ? '#aaa' : '#666';
            ctx.textAlign = 'center';
            ctx.fillText('[ NEXT SCENE ]', sb.x + sb.w / 2, sb.y + 4);

            // Instructions
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText('CLICK ENTITY TO SELECT • CLICK VECTOR TO TRIGGER', UI.margin, h - UI.margin);

            requestAnimationFrame(draw);
        }

        // Init
        window.addEventListener('resize', resize);
        resize();
        engine.loadScenario('cupboard');
        draw();
    </script>
</body>

</html>