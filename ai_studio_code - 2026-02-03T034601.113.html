<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORCA x RIPPLES // OPERATIVE SEQUENCER</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg: #050505;
            --fg: #4af626;
            --dim: #1a5c0d;
            --gold: #ffcc00;
            --red: #ff3333;
            --cyan: #00ffff;
            --wave: #ffffff;
        }

        @font-face {
            font-family: 'Unscii';
            src: url('https://cdnjs.cloudflare.com/ajax/libs/unscii/1.0.0/unscii-16-full.ttf') format('truetype');
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', monospace; /* Fallback */
            font-family: 'Unscii', monospace; 
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* CRT OVERLAY */
        #crt {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 99;
            opacity: 0.4;
        }

        /* UI LAYOUT */
        #interface {
            display: grid;
            grid-template-columns: 1fr 300px;
            width: 95vw;
            height: 90vh;
            gap: 20px;
        }

        /* ORCA GRID */
        #grid-wrapper {
            position: relative;
            border: 1px solid var(--dim);
            overflow: hidden;
            background: #000;
            cursor: text;
        }

        #grid-canvas {
            display: block;
        }

        /* INFO PANEL */
        aside {
            border-left: 1px solid var(--dim);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            font-size: 12px;
            line-height: 1.5;
        }

        h1 { margin: 0; font-size: 16px; color: var(--fg); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { color: var(--dim); margin-bottom: 20px; display: block; }

        .stat-block {
            border: 1px solid var(--dim);
            padding: 10px;
        }
        
        .worldtext-log {
            flex-grow: 1;
            overflow-y: auto;
            border-top: 1px dashed var(--dim);
            padding-top: 10px;
            font-size: 10px;
            color: var(--fg);
            display: flex;
            flex-direction: column-reverse;
        }

        .log-entry { margin-bottom: 8px; opacity: 0.8; }
        .log-G { color: var(--gold); }
        .log-O { color: var(--red); }
        .log-S { color: var(--cyan); }

        /* BLINKER */
        .cursor {
            background-color: var(--fg);
            color: var(--bg);
        }
    </style>
</head>
<body>

    <div id="crt"></div>

    <div id="interface">
        <div id="grid-wrapper">
            <canvas id="grid-canvas"></canvas>
        </div>

        <aside>
            <div>
                <h1>ORCA x RIPPLES</h1>
                <span class="subtitle">OPERATIVE SEQUENCER v1.0</span>
                
                <div class="stat-block">
                    <div>TICK: <span id="tick-disp">0000</span></div>
                    <div>BPM: <span id="bpm-disp">120</span></div>
                    <div style="margin-top:10px; color: var(--dim)">
                        KEYS:<br>
                        [A] ANIMATE (Agent)<br>
                        [@] RIPPLE (Radial)<br>
                        [*] BANG (Trigger)<br>
                        [G] GOAL (Tone)<br>
                        [O] OBSTACLE (Noise)<br>
                        [SPACE] PLAY/PAUSE
                    </div>
                </div>
            </div>

            <div class="worldtext-log" id="worldtext">
                <div class="log-entry">> SYSTEM READY. CLICK TO INITIALIZE AUDIO.</div>
            </div>
        </aside>
    </div>

<script>
    /**
     * ORCA RIPPLE THEORY IMPLEMENTATION
     * 1. Grid Logic (Cellular Automata)
     * 2. Radial Propagation (@ Operator)
     * 3. Vector Synthesis (Audio Bridge)
     */

    // --- CONFIG ---
    const COLS = 46;
    const ROWS = 28;
    const FONT_SIZE = 16;
    const CHAR_W = 10;
    const CHAR_H = 18;

    // --- STATE ---
    let grid = [];
    let nextGrid = []; // Double buffer
    let ripples = []; // Active radial waves [{x, y, age, max}]
    let tick = 0;
    let isPlaying = false;
    let cursor = { x: 10, y: 10 };
    
    // --- AUDIO CONTEXT ---
    const Audio = {
        synth: null,
        noise: null,
        filter: null,
        bitcrusher: null,
        ready: false,

        init: async () => {
            if(Audio.ready) return;
            await Tone.start();
            
            // 1. The Harmonic Voice (Goal)
            Audio.synth = new Tone.PolySynth(Tone.FMSynth, {
                harmonicity: 3, modulationIndex: 10,
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 1 }
            }).toDestination();
            Audio.synth.volume.value = -10;

            // 2. The Noise Voice (Obstacle)
            Audio.bitcrusher = new Tone.BitCrusher(4).toDestination();
            Audio.noise = new Tone.NoiseSynth({
                envelope: { attack: 0.01, decay: 0.1, sustain: 0 }
            }).connect(Audio.bitcrusher);
            Audio.noise.volume.value = -15;

            // 3. The Atmosphere (Shift)
            Audio.filter = new Tone.Filter(200, "lowpass").toDestination();
            const drone = new Tone.Oscillator(60, "sawtooth").connect(Audio.filter).start();
            drone.volume.value = -30;

            Audio.ready = true;
            log("AUDIO ENGINE ONLINE", "S");
        },

        trigger: (type, val) => {
            if(!Audio.ready) return;
            
            // Vector Synthesis Mapping
            if(type === 'G') {
                // GOAL: Pitch / Harmony
                const notes = ["C4", "E4", "G4", "B4", "D5", "F#5"];
                const note = notes[val % notes.length];
                Audio.synth.triggerAttackRelease(note, "16n");
            } 
            else if(type === 'O') {
                // OBSTACLE: Distortion / Noise
                Audio.bitcrusher.bits.value = Math.max(1, 8 - val);
                Audio.noise.triggerAttackRelease("32n");
            }
            else if(type === 'S') {
                // SHIFT: Modulation
                Audio.filter.frequency.rampTo(val * 100 + 100, 0.1);
            }
            else if(type === '@') {
                // RIPPLE: Pad Wash
                Audio.synth.triggerAttackRelease(["C3", "G3"], "8n");
            }
        }
    };

    // --- GRID OPS ---
    function initGrid() {
        grid = new Array(ROWS * COLS).fill('.');
        
        // Load Default Patch (The Scenario)
        writeStr(10, 10, "A"); // Ant
        writeStr(12, 10, "*"); // Bang
        writeStr(13, 10, "G4"); // Goal (Pitch 4)
        writeStr(20, 15, "@"); // Ripple Generator
        writeStr(20, 14, "*"); // Trigger for Ripple
        writeStr(30, 8, "O8"); // Obstacle
    }

    function getCell(x, y) {
        if(x < 0 || x >= COLS || y < 0 || y >= ROWS) return null;
        return grid[y * COLS + x];
    }

    function setCell(x, y, char, gridRef = nextGrid) {
        if(x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
        gridRef[y * COLS + x] = char;
    }

    function writeStr(x, y, str) {
        for(let i=0; i<str.length; i++) {
            setCell(x+i, y, str[i], grid);
        }
    }

    // --- CORE LOGIC LOOP ---
    function runTick() {
        tick++;
        document.getElementById('tick-disp').innerText = tick.toString().padStart(4, '0');
        
        // Deep copy for double buffering
        nextGrid = [...grid];
        
        // Clear old visual artifacts (waves)
        for(let i=0; i<nextGrid.length; i++) {
            if(nextGrid[i] === '~' || nextGrid[i] === '+') nextGrid[i] = '.';
        }

        // Process Ripples (Radial Propagation)
        let activeRipples = [];
        ripples.forEach(r => {
            r.age++;
            if(r.age < r.max) {
                // Draw Wave
                drawRippleWave(r);
                activeRipples.push(r);
            }
        });
        ripples = activeRipples;

        // Iterate Grid (The Operative Scan)
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                const char = grid[y * COLS + x];
                if(char === '.') continue;

                // 1. ANIMATE ENTITIES (A)
                if(char === 'A') {
                    // Random Movement
                    if(tick % 4 === 0) {
                        setCell(x, y, '.', nextGrid); // Clear old
                        const dir = [[0,1], [0,-1], [1,0], [-1,0]][Math.floor(Math.random()*4)];
                        const nx = x + dir[0];
                        const ny = y + dir[1];
                        
                        // Collision check
                        const target = getCell(nx, ny);
                        if(target === '.' || target === '~') {
                            setCell(nx, ny, 'A', nextGrid);
                        } else {
                            // Hit something!
                            setCell(x, y, 'A', nextGrid); // Stay put
                            if(target === '*') setCell(nx, ny, '*', nextGrid); // Re-trigger bang
                        }
                    }
                }

                // 2. BANG (*)
                if(char === '*') {
                    setCell(x, y, '.', nextGrid); // Bangs dissolve
                    
                    // Trigger Neighbors
                    const neighbors = [[0,1], [0,-1], [1,0], [-1,0]];
                    neighbors.forEach(n => {
                        const nx = x+n[0];
                        const ny = y+n[1];
                        const op = getCell(nx, ny);
                        
                        // Interaction Logic
                        if(op === 'G') { Audio.trigger('G', parseVal(getCell(nx+1, ny))); log("GOAL REACHED", "G"); }
                        if(op === 'O') { Audio.trigger('O', parseVal(getCell(nx+1, ny))); log("OBSTACLE HIT", "O"); }
                        if(op === 'S') { Audio.trigger('S', parseVal(getCell(nx+1, ny))); log("PHASE SHIFT", "S"); }
                        if(op === '@') { 
                            // Spawn Radial Ripple
                            ripples.push({x: nx, y: ny, age: 0, max: 10});
                            Audio.trigger('@', 0);
                            log("RIPPLE PROPAGATION", "S");
                        }
                    });
                }
            }
        }

        grid = nextGrid;
        draw();
    }

    // --- RIPPLE PHYSICS ---
    function drawRippleWave(r) {
        // Bresenham-ish circle for grid
        for (let y = -r.age; y <= r.age; y++) {
            for (let x = -r.age; x <= r.age; x++) {
                if (x*x + y*y <= r.age*r.age && x*x + y*y > (r.age-1)*(r.age-1)) {
                    const tx = r.x + x;
                    const ty = r.y + y;
                    const char = getCell(tx, ty);
                    
                    if(char === '.') {
                        setCell(tx, ty, '~', nextGrid); // Visual Wave
                    } else if ("GOSA".includes(char)) {
                        // "Write-Back Loop": High energy ripple stimulates operators
                        setCell(tx, ty, '*', nextGrid); // Trigger operator remotely!
                    }
                }
            }
        }
    }

    function parseVal(char) {
        if(!char) return 0;
        const val = parseInt(char, 36);
        return isNaN(val) ? 0 : val;
    }

    // --- VISUALIZATION ---
    const canvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
        canvas.width = document.getElementById('grid-wrapper').offsetWidth;
        canvas.height = document.getElementById('grid-wrapper').offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = '16px Unscii, monospace';
        ctx.textBaseline = 'top';

        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                const char = grid[y * COLS + x];
                const px = x * CHAR_W + 10;
                const py = y * CHAR_H + 10;

                // Color Coding based on Theory
                if(char === 'A') { ctx.fillStyle = '#fff'; }
                else if(char === '@') { ctx.fillStyle = 'var(--wave)'; }
                else if(char === '~') { ctx.fillStyle = 'rgba(255,255,255,0.3)'; }
                else if(char === 'G') { ctx.fillStyle = 'var(--gold)'; }
                else if(char === 'O') { ctx.fillStyle = 'var(--red)'; }
                else if(char === 'S') { ctx.fillStyle = 'var(--cyan)'; }
                else if(char === '*') { ctx.fillStyle = '#fff'; }
                else { ctx.fillStyle = 'var(--dim)'; }

                // Cursor
                if(x === cursor.x && y === cursor.y) {
                    ctx.fillStyle = 'var(--fg)';
                    ctx.fillRect(px, py, CHAR_W, CHAR_H);
                    ctx.fillStyle = '#000';
                }

                ctx.fillText(char, px, py);
            }
        }
    }

    // --- NARRATIVE LOG ---
    const logs = [
        "The Ant encounters a vertical cliff of ceramic.",
        "A shadow lengthens, consuming definition.",
        "Vibration detected. The glass sings.",
        "Metabolic torpor initiated.",
        "The obstacle resists the vector of desire."
    ];

    function log(msg, type) {
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;
        
        // If generic trigger, pick poetic text
        if(type === 'G' || type === 'O') {
            const poetic = logs[Math.floor(Math.random() * logs.length)];
            div.innerText = `${tick} | ${msg} | "${poetic}"`;
        } else {
            div.innerText = `${tick} | ${msg}`;
        }
        
        document.getElementById('worldtext').prepend(div);
        if(document.getElementById('worldtext').children.length > 20) {
            document.getElementById('worldtext').lastChild.remove();
        }
    }

    // --- INPUT ---
    window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowUp') cursor.y = Math.max(0, cursor.y - 1);
        if(e.key === 'ArrowDown') cursor.y = Math.min(ROWS - 1, cursor.y + 1);
        if(e.key === 'ArrowLeft') cursor.x = Math.max(0, cursor.x - 1);
        if(e.key === 'ArrowRight') cursor.x = Math.min(COLS - 1, cursor.x + 1);
        
        if(e.key === ' ') {
            e.preventDefault();
            isPlaying = !isPlaying;
            if(isPlaying) Audio.init();
        }

        if(e.key.length === 1) {
            setCell(cursor.x, cursor.y, e.key.toUpperCase(), grid);
        }
        
        if(e.key === 'Backspace') {
            setCell(cursor.x, cursor.y, '.', grid);
        }

        draw();
    });

    window.addEventListener('mousedown', () => {
        Audio.init();
    });

    // Boot
    initGrid();
    setInterval(() => {
        if(isPlaying) runTick();
    }, 150); // Speed

</script>
</body>
</html>