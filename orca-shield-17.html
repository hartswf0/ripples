<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ORCA // SHIELD_COMPILER_V17</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            /* SHIELD PALETTE */
            --color-bg: #050505;
            --color-primary: #72dec2;
            /* Orca Teal */
            --color-secondary: #666666;
            /* Orca Grey */
            --color-highlight: #ffffff;
            /* Orca White */
            --color-forge: #ff4500;
            /* Vulcan Red */
            --color-cosmos: #9370db;
            /* Starry Purple */
            --color-peace: #ffd700;
            /* Golden City */
            --color-war: #8b0000;
            /* Crimson War */
            --color-rural: #228b22;
            /* Green Earth */
            --color-ocean: #00ced1;
            /* Silver/Blue Rim */

            /* RAYCASTER PALETTE */
            --ui-text: #00ff41;
            --ui-dim: rgba(0, 255, 65, 0.2);
            --font-stack: 'Courier New', Courier, monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-stack);
        }

        /* --- THE CHASSIS --- */
        .monitor-frame {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        /* --- LAYERS --- */
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #layer-grid {
            z-index: 10;
            display: block;
        }

        #layer-raycaster {
            z-index: 20;
            display: none;
            background: #000;
        }

        .active-mode-grid #layer-grid {
            display: block;
            pointer-events: auto;
        }

        .active-mode-grid #layer-raycaster {
            display: none;
            pointer-events: none;
        }

        .active-mode-void #layer-grid {
            display: none;
            pointer-events: none;
        }

        .active-mode-void #layer-raycaster {
            display: block;
            pointer-events: auto;
        }

        /* --- GRID UI --- */
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0.15;
            animation: flicker 0.1s infinite;
        }

        @keyframes flicker {
            0% {
                opacity: 0.15;
            }

            50% {
                opacity: 0.12;
            }

            100% {
                opacity: 0.18;
            }
        }

        #viz-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .header-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 50;
            display: flex;
            gap: 15px;
        }

        .btn-ui {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--color-secondary);
            color: var(--color-secondary);
            padding: 5px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }

        .btn-ui:hover {
            border-color: var(--color-primary);
            color: var(--color-primary);
        }

        .btn-void {
            border-color: var(--color-forge);
            color: var(--color-forge);
        }

        .btn-void:hover {
            border-color: #fff;
            color: #fff;
            background: var(--color-forge);
        }

        .reader-panel {
            position: absolute;
            left: 20px;
            top: 80px;
            bottom: 120px;
            width: 300px;
            z-index: 30;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .panel-header {
            border-bottom: 1px solid var(--color-secondary);
            padding-bottom: 5px;
            color: #fff;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .poem-text {
            border-left: 2px solid var(--color-primary);
            padding-left: 15px;
            min-height: 100px;
            color: #fff;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            line-height: 1.4;
            font-size: 0.9rem;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .meta-tag {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            font-size: 0.7rem;
            border: 1px solid #444;
            color: #888;
        }

        .hud-overlay {
            position: absolute;
            bottom: 100px;
            right: 10px;
            z-index: 25;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .hud-panel {
            color: var(--color-secondary);
            font-size: 0.65rem;
            pointer-events: auto;
        }

        .hud-minimap {
            width: 80px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            pointer-events: auto;
        }

        .controls-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            z-index: 30;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
            color: #444;
            font-size: 0.7rem;
            letter-spacing: 2px;
        }

        /* --- RAYCASTER UI --- */
        #raycaster-canvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .scanner {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 500px;
            pointer-events: none;
            z-index: 40;
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: center;
        }

        .scanner-header {
            display: flex;
            justify-content: center;
            gap: 10px;
            pointer-events: auto;
        }

        .scanner-label {
            font-size: 0.6rem;
            background: var(--ui-text);
            color: #000;
            padding: 2px 6px;
            font-weight: bold;
        }

        .scanner-btn {
            font-size: 0.6rem;
            background: transparent;
            color: var(--ui-text);
            border: 1px solid var(--ui-text);
            padding: 2px 6px;
            cursor: pointer;
            pointer-events: auto;
        }

        .scanner-btn:hover {
            background: var(--ui-text);
            color: #000;
        }

        .scanner-text {
            background: rgba(5, 5, 5, 0.9);
            padding: 12px;
            border: 1px solid var(--ui-text);
            color: #fff;
            font-size: 0.9rem;
            line-height: 1.4;
            max-height: 100px;
            overflow: hidden;
            white-space: pre-wrap;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 35;
        }

        /* IMAGE MODAL */
        #img-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            pointer-events: auto;
        }

        #img-modal.active {
            display: flex;
        }

        #gen-image-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 16/9;
            border: 1px solid var(--ui-text);
            background: #000;
            margin-bottom: 10px;
        }

        #gen-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .modal-caption {
            color: #fff;
            text-align: center;
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 10px;
            min-height: 1.5em;
        }

        /* BOOT SCREEN */
        #boot-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 30000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--color-primary);
        }
    </style>
</head>

<body class="active-mode-grid">

    <div id="boot-screen">
        <div
            style="font-size: 1.5rem; letter-spacing: 4px; margin-bottom: 20px; animation: flicker 0.2s infinite alternate;">
            ORCA // SHIELD_COMPILER_V17</div>
        <div style="font-size: 0.8rem; color: #666; margin-bottom: 40px;">OPERATIVE EKPHRASIS MODULE</div>
        <button onclick="System.init()"
            style="background: transparent; color: #fff; border: 1px solid var(--color-primary); padding: 15px 30px; font-family: inherit; font-size: 1rem; cursor: pointer;">ENTER
            THE FORGE</button>
    </div>

    <div class="monitor-frame">
        <div class="crt-overlay"></div>

        <!-- HEADER (Global) -->
        <div class="header-controls">
            <button class="btn-ui" onclick="GridRenderer.toggleView()" id="view-btn">VIEW: ORBIT</button>
            <button class="btn-ui" onclick="GridRenderer.resetView()">RECENTER</button>
            <button class="btn-ui btn-void" id="mode-toggle" onclick="System.toggleMode()">ENTER VOID</button>
            <button class="btn-ui"
                onclick="alert('GRID: Hover to Read, Click to Ripple.\nVOID: WASD/Arrow Keys to Move, Space to Scan.')">?</button>
        </div>

        <!-- LAYER 1: GRID -->
        <div id="layer-grid" class="layer">
            <canvas id="viz-canvas"></canvas>

            <div class="reader-panel" id="reader-panel">
                <div id="zone-header" class="panel-header" style="color: var(--color-secondary)">SCANNING...</div>
                <div id="text-display" class="poem-text">Hover to read the substrate.</div>
                <div id="tag-display" class="tag-list"></div>
            </div>

            <div class="hud-overlay">
                <div class="hud-panel" id="ui-coords">0,0</div>
                <canvas id="minimap-canvas" class="hud-minimap"></canvas>
            </div>

            <div class="controls-bar">
                <div>NAVIGATION IS READING // CLICK TO FORGE RIPPLES</div>
            </div>
        </div>

        <!-- LAYER 2: RAYCASTER -->
        <div id="layer-raycaster" class="layer">
            <canvas id="raycaster-canvas"></canvas>
            <div class="crosshair"></div>

            <div class="scanner">
                <div class="scanner-text" id="scanner-output">...</div>
                <div class="scanner-header">
                    <div class="scanner-label">SEMANTIC RAYCASTER</div>
                    <button class="scanner-btn" onclick="RaycasterEngine.speakBuffer()">üîä SPEAK</button>
                    <button class="scanner-btn" onclick="RaycasterEngine.generateFromBuffer()">üëÅÔ∏è VISION</button>
                </div>
            </div>

            <!-- VISION MODE TOGGLE -->
            <div id="vision-modes"
                style="position:absolute; top:70px; left:50%; transform:translateX(-50%); display:flex; gap:5px; z-index:100;">
                <button class="btn-ui" style="padding:8px 12px;" onclick="RaycasterEngine.setVision('NORMAL')"
                    id="vis-normal">üî¶ NORMAL</button>
                <button class="btn-ui" style="padding:8px 12px;" onclick="RaycasterEngine.setVision('PRISM')"
                    id="vis-prism">üåà PRISM</button>
                <button class="btn-ui" style="padding:8px 12px;" onclick="RaycasterEngine.setVision('CONCAVE')"
                    id="vis-concave">üîç CONCAVE</button>
            </div>

            <!-- COLLECTION HUD -->
            <div id="collect-hud"
                style="position:absolute; top:20px; left:20px; background:rgba(0,0,0,0.7); border:1px solid var(--ui-text); padding:10px 15px; z-index:100; font-size:0.9rem; color:var(--ui-text);">
                <div style="letter-spacing:2px; margin-bottom:5px;">TEXT COLLECTED</div>
                <div id="collect-count" style="font-size:1.5rem; font-weight:bold;">0 / 10</div>
            </div>

            <!-- MOBILE JOYSTICKS -->
            <div id="mobile-controls"
                style="position:absolute; bottom:0; left:0; right:0; height:180px; display:flex; justify-content:space-between; padding:20px; pointer-events:none; z-index:90;">
                <!-- LEFT: MOVE -->
                <div id="joystick-left"
                    style="width:120px; height:120px; background:rgba(0,255,65,0.15); border:2px solid rgba(0,255,65,0.5); border-radius:50%; position:relative; pointer-events:auto; touch-action:none;">
                    <div id="joystick-left-knob"
                        style="width:50px; height:50px; background:rgba(0,255,65,0.6); border-radius:50%; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);">
                    </div>
                    <div
                        style="position:absolute; top:-18px; left:50%; transform:translateX(-50%); font-size:10px; color:#0f0; letter-spacing:2px;">
                        MOVE</div>
                </div>

                <!-- CENTER: D-PAD -->
                <div id="dpad"
                    style="display:flex; flex-direction:column; align-items:center; gap:5px; pointer-events:auto;">
                    <button class="dpad-btn" ontouchstart="RaycasterEngine.keys.w=true"
                        ontouchend="RaycasterEngine.keys.w=false" onmousedown="RaycasterEngine.keys.w=true"
                        onmouseup="RaycasterEngine.keys.w=false"
                        style="width:50px; height:40px; background:rgba(0,255,65,0.3); border:1px solid #0f0; color:#0f0; font-size:18px;">‚ñ≤</button>
                    <div style="display:flex; gap:10px;">
                        <button class="dpad-btn" ontouchstart="RaycasterEngine.keys.a=true"
                            ontouchend="RaycasterEngine.keys.a=false" onmousedown="RaycasterEngine.keys.a=true"
                            onmouseup="RaycasterEngine.keys.a=false"
                            style="width:40px; height:40px; background:rgba(0,255,65,0.3); border:1px solid #0f0; color:#0f0; font-size:18px;">‚óÄ</button>
                        <button class="dpad-btn" ontouchstart="RaycasterEngine.keys.s=true"
                            ontouchend="RaycasterEngine.keys.s=false" onmousedown="RaycasterEngine.keys.s=true"
                            onmouseup="RaycasterEngine.keys.s=false"
                            style="width:40px; height:40px; background:rgba(0,255,65,0.3); border:1px solid #0f0; color:#0f0; font-size:18px;">‚ñº</button>
                        <button class="dpad-btn" ontouchstart="RaycasterEngine.keys.d=true"
                            ontouchend="RaycasterEngine.keys.d=false" onmousedown="RaycasterEngine.keys.d=true"
                            onmouseup="RaycasterEngine.keys.d=false"
                            style="width:40px; height:40px; background:rgba(0,255,65,0.3); border:1px solid #0f0; color:#0f0; font-size:18px;">‚ñ∂</button>
                    </div>
                </div>

                <!-- RIGHT: LOOK -->
                <div id="joystick-right"
                    style="width:120px; height:120px; background:rgba(255,69,0,0.15); border:2px solid rgba(255,69,0,0.5); border-radius:50%; position:relative; pointer-events:auto; touch-action:none;">
                    <div id="joystick-right-knob"
                        style="width:50px; height:50px; background:rgba(255,69,0,0.6); border-radius:50%; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);">
                    </div>
                    <div
                        style="position:absolute; top:-18px; left:50%; transform:translateX(-50%); font-size:10px; color:#f40; letter-spacing:2px;">
                        LOOK</div>
                </div>
            </div>

            <!-- SCAN BUTTON -->
            <button id="scan-btn" onclick="RaycasterEngine.scan()"
                style="position:absolute; bottom:200px; left:50%; transform:translateX(-50%); padding:15px 30px; background:rgba(0,255,65,0.2); border:2px solid #0f0; color:#0f0; font-family:inherit; font-size:1rem; cursor:pointer; z-index:100;">üîä
                SCAN / COLLECT</button>
        </div>
    </div>

    <!-- VISION MODAL -->
    <div id="img-modal">
        <div id="gen-image-container">
            <img id="gen-image" src="" alt="Neural Vision">
        </div>
        <div class="modal-caption" id="gen-caption">Initializing Neural Link...</div>
        <button class="btn-ui" onclick="document.getElementById('img-modal').classList.remove('active')">CLOSE
            SIGNAL</button>
    </div>

    <script>
        // --- SHARED DATA ---
        const POEM_DATA = {
            forge: ["Thee, welcome, goddess! what occasion calls", "And Vulcan's joy and duty to obey.", "To the black labours of his forge retires.", "In hissing flames huge silver bars are roll'd", "The ponderous hammer loads his better hand"],
            cosmos: ["The unwearied sun, the moon completely round;", "The starry lights that heaven's high convex crown'd;", "The Pleiads, Hyads, with the northern team;", "And great Orion's more refulgent beam;"],
            cities: ["Two cities radiant on the shield appear,", "Here sacred pomp and genial feast delight,", "Another part (a prospect differing far)", "Glow'd with refulgent arms, and horrid war."],
            rural: ["A field deep furrow'd next the god design'd,", "The shining shares full many ploughmen guide,", "Next, ripe in yellow gold, a vineyard shines,", "Two lions rushing from the wood appear'd;"],
            ocean: ["Thus the broad shield complete the artist crown'd", "In living silver seem'd the waves to roll,", "And beat the buckler's verge, and bound the whole.", "Oceanus flows", "Silver Tide"]
        };

        const ZONES = {
            FORGE: { name: "THE FORGE", color: "#ff4500", minR: 0, maxR: 3.5 },
            COSMOS: { name: "COSMOS", color: "#9370db", minR: 3.5, maxR: 6 },
            CITIES: { name: "CITIES", color: "#ffd700", minR: 6, maxR: 9.5 },
            RURAL: { name: "RURAL", color: "#228b22", minR: 9.5, maxR: 11.5 },
            OCEAN: { name: "OCEANUS", color: "#00ced1", minR: 11.5, maxR: 99 }
        };

        const KEYWORDS = {
            "GOLD": "#FFD700", "SUN": "#FFA500", "FIRE": "#FF4500", "RADIANT": "#FFFFE0",
            "BLOOD": "#8A0303", "WAR": "#B22222", "OCEAN": "#00BFFF", "SKY": "#87CEEB", "VOID": "#333333"
        };

        // --- AUDIO ---
        const AudioEngine = {
            initialized: false,
            thudSynth: null, droneSynth: null,
            async init() {
                if (this.initialized) return;
                await Tone.start();
                this.thudSynth = new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 1.5, envelope: { attack: 0.001, decay: 0.3, sustain: 0 } }).toDestination();
                this.thudSynth.volume.value = -10;
                this.droneSynth = new Tone.FMSynth().toDestination();
                this.droneSynth.volume.value = -25;
                this.initialized = true;
            },
            trigger(zone) {
                if (!this.initialized) return;
                if (zone.includes("FORGE")) this.thudSynth.triggerAttackRelease("C1", "16n");
                else if (zone.includes("COSMOS")) this.thudSynth.triggerAttackRelease("G2", "16n");
                else if (zone.includes("OCEAN")) this.droneSynth.triggerAttackRelease("A2", "32n");
                else this.thudSynth.triggerAttackRelease("E2", "32n");
            },
            rippleThud(vel = 0.5) {
                if (!this.initialized) return;
                this.thudSynth.triggerAttackRelease("C1", "32n", Tone.now(), vel);
            }
        };

        // --- GRID PHYSICS (RIPPLES) ---
        const GridEngine = {
            ripples: [],
            spawn(x, y, color = "#fff", text = ".") {
                this.ripples.push({
                    x, y, color, text,
                    born: Date.now(), lifeMax: 100, life: 0, radius: 0, strength: 40
                });
                AudioEngine.rippleThud();
            },
            update() {
                for (let i = this.ripples.length - 1; i >= 0; i--) {
                    const r = this.ripples[i];
                    r.life++; r.radius += 0.15;
                    if (r.life > r.lifeMax) this.ripples.splice(i, 1);
                }
            }
        };

        // --- GRID RENDERER (SHIELD) ---
        const GridRenderer = {
            canvas: document.getElementById('viz-canvas'),
            ctx: document.getElementById('viz-canvas').getContext('2d'),
            minimapCtx: document.getElementById('minimap-canvas').getContext('2d'),
            gridSize: 24, center: 11.5,
            gridState: [],
            zoom: 1.0, PanX: 0, PanY: 0,
            viewMode: 'ORBIT', // 'ORBIT' or 'TOPO'
            isDragging: false, lastX: 0, lastY: 0, hoverCell: null, time: 0,

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Interaction
                this.canvas.addEventListener('mousedown', e => {
                    this.isDragging = false;
                    this.startX = e.clientX; this.startY = e.clientY;
                });
                this.canvas.addEventListener('mousemove', e => {
                    if (e.buttons === 1) { // Dragging logic
                        if (Math.hypot(e.clientX - this.startX, e.clientY - this.startY) > 5) this.isDragging = true;
                        if (this.isDragging) {
                            this.PanX += e.clientX - this.lastX;
                            this.PanY += e.clientY - this.lastY;
                        }
                    }
                    this.lastX = e.clientX; this.lastY = e.clientY;
                    this.mousePos = { x: e.clientX - this.canvas.getBoundingClientRect().left, y: e.clientY - this.canvas.getBoundingClientRect().top };
                });
                this.canvas.addEventListener('mouseup', e => {
                    if (!this.isDragging) { // Click logic
                        this.handleClick(e.clientX, e.clientY);
                    }
                    this.isDragging = false;
                });
                this.canvas.addEventListener('wheel', e => {
                    this.zoom = Math.min(Math.max(0.5, this.zoom - e.deltaY * 0.001), 3.0);
                });

                // Init Grid Data
                this.gridState = new Array(this.gridSize).fill(0).map((_, y) =>
                    new Array(this.gridSize).fill(0).map((_, x) => this.compileCell(x, y))
                );
            },

            resize() {
                this.canvas.width = this.canvas.parentElement.offsetWidth;
                this.canvas.height = this.canvas.parentElement.offsetHeight;
                this.cx = this.canvas.width / 2; this.cy = this.canvas.height / 2;
            },

            resetView() { this.PanX = 0; this.PanY = 0; this.zoom = 1.0; this.viewMode = 'ORBIT'; document.getElementById('view-btn').innerText = "VIEW: ORBIT"; },

            toggleView() {
                this.viewMode = this.viewMode === 'ORBIT' ? 'TOPO' : 'ORBIT';
                document.getElementById('view-btn').innerText = "VIEW: " + this.viewMode;
            },

            compileCell(x, y) {
                const dx = x - this.center; const dy = y - this.center;
                const r = Math.sqrt(dx * dx + dy * dy);
                const theta = Math.atan2(dy, dx);
                let cell = { char: '.', color: '#333', zone: 'VOID', text: '', tags: [], r, theta };

                if (r < ZONES.FORGE.maxR) {
                    cell = { ...cell, zone: ZONES.FORGE.name, color: ZONES.FORGE.color, text: POEM_DATA.forge[Math.floor(Math.abs(x + y)) % POEM_DATA.forge.length], char: "X" };
                } else if (r < ZONES.COSMOS.maxR) {
                    cell = { ...cell, zone: ZONES.COSMOS.name, color: ZONES.COSMOS.color, text: POEM_DATA.cosmos[Math.floor(Math.abs(x * y)) % POEM_DATA.cosmos.length], char: "*" };
                } else if (r < ZONES.CITIES.maxR) {
                    cell = { ...cell, zone: ZONES.CITIES.name, color: ZONES.CITIES.color, text: POEM_DATA.cities[Math.floor(Math.abs(y)) % POEM_DATA.cities.length], char: "o" };
                } else if (r < ZONES.RURAL.maxR) {
                    cell = { ...cell, zone: ZONES.RURAL.name, color: ZONES.RURAL.color, text: POEM_DATA.rural[Math.floor(Math.abs(x)) % POEM_DATA.rural.length], char: "," };
                } else {
                    cell = { ...cell, zone: ZONES.OCEAN.name, color: ZONES.OCEAN.color, text: POEM_DATA.ocean[Math.floor(Math.abs(x + y)) % POEM_DATA.ocean.length], char: "~" };
                }
                return { ...cell, x, y };
            },

            handleClick(screenX, screenY) {
                if (this.hoverCell) {
                    // Reverse project logic is hard, so we just spawn ripple at hoverCell location in grid space
                    // But ripples need grid coordinates to render z-offset
                    GridEngine.spawn(this.hoverCell.x - this.center, this.hoverCell.y - this.center, this.hoverCell.color, this.hoverCell.char);
                }
            },

            loop() {
                if (System.mode !== 'GRID') return;
                this.time += 0.01;
                GridEngine.update();

                this.ctx.fillStyle = '#050505';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const isoW = 24 * this.zoom; const isoH = 12 * this.zoom;
                let closest = null; let minDist = 1000;

                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const rx = x - this.center; const ry = y - this.center;

                        // Z Calculation including Ripples
                        let z = Math.sin((Math.sqrt(rx * rx + ry * ry) * 0.5) - this.time) * 5;
                        GridEngine.ripples.forEach(ri => {
                            const d = Math.abs(Math.sqrt((rx - ri.x) ** 2 + (ry - ri.y) ** 2) - ri.radius);
                            if (d < 5) z += Math.cos(d * 0.5) * ri.strength * Math.max(0, (ri.lifeMax - ri.life) / ri.lifeMax);
                        });

                        const cell = this.gridState[y][x];

                        // --- TOPO RENDER ---
                        if (this.viewMode === 'TOPO') {
                            // Logic: We render lines by connecting points in a ring (same radius bucket)
                            // But the grid is cartesian. So we just render points as connected lines if we wanted
                            // simplified: Render lines instead of chars.

                            // 3D Projection for Topo (Flatter angle)
                            const topoScale = 25 * this.zoom;
                            const sx = this.cx + this.PanX + (rx - ry) * (topoScale);
                            const sy = this.cy + this.PanY + (rx + ry) * (topoScale * 0.3) - (z * this.zoom * 3); // Emphasize height

                            if (sx < -50 || sx > this.canvas.width + 50 || sy < -50 || sy > this.canvas.height + 50) continue;

                            // Draw "Ridgeline" segments
                            // Since we iterate X/Y, we can just draw lines to neighbors
                            if (x < this.gridSize - 1) {
                                const nextRx = (x + 1) - this.center;

                                // Calc Z for neighbor
                                let nextZ = Math.sin((Math.sqrt(nextRx * nextRx + ry * ry) * 0.5) - this.time) * 5;
                                GridEngine.ripples.forEach(ri => {
                                    const d = Math.abs(Math.sqrt((nextRx - ri.x) ** 2 + (ry - ri.y) ** 2) - ri.radius);
                                    if (d < 5) nextZ += Math.cos(d * 0.5) * ri.strength * Math.max(0, (ri.lifeMax - ri.life) / ri.lifeMax);
                                });

                                const nextSx = this.cx + this.PanX + (nextRx - ry) * (topoScale);
                                const nextSy = this.cy + this.PanY + (nextRx + ry) * (topoScale * 0.3) - (nextZ * this.zoom * 3);

                                this.ctx.beginPath();
                                this.ctx.moveTo(sx, sy);
                                this.ctx.lineTo(nextSx, nextSy);
                                this.ctx.strokeStyle = cell.color;
                                this.ctx.lineWidth = 2 * this.zoom;
                                this.ctx.globalAlpha = 0.6;
                                this.ctx.stroke();
                            }

                            // Draw Vertical Line to base (Matrix/Topo feel)
                            /*
                            this.ctx.beginPath();
                            this.ctx.moveTo(sx, sy);
                            this.ctx.lineTo(sx, sy + (z*5)); 
                            this.ctx.strokeStyle = cell.color; this.ctx.lineWidth=0.5; this.ctx.stroke();
                            */

                            // Mouse Interaction in TOPO
                            if (this.mousePos) {
                                const d = Math.hypot(sx - this.mousePos.x, sy - this.mousePos.y);
                                if (d < 30 * this.zoom && d < minDist) { minDist = d; closest = { ...cell, sx, sy }; }
                            }

                        } else {
                            // --- ORBIT RENDER (Standard) ---
                            const sx = this.cx + this.PanX + (rx - ry) * isoW;
                            const sy = this.cy + this.PanY + (rx + ry) * isoH - (z * this.zoom);

                            if (sx < -20 || sx > this.canvas.width + 20 || sy < -20 || sy > this.canvas.height + 20) continue;

                            if (this.mousePos) {
                                const d = Math.hypot(sx - this.mousePos.x, sy - this.mousePos.y);
                                if (d < 20 * this.zoom && d < minDist) { minDist = d; closest = { ...cell, sx, sy }; }
                            }

                            this.ctx.fillStyle = cell.color;
                            this.ctx.font = `${Math.floor(12 * this.zoom)}px monospace`;
                            this.ctx.textAlign = "center";
                            this.ctx.globalAlpha = 0.8;
                            this.ctx.fillText(cell.char, sx, sy);
                        }
                    }
                }

                if (closest && closest !== this.hoverCell) {
                    this.hoverCell = closest;
                    document.getElementById('text-display').innerText = `"${closest.text}"`;
                    document.getElementById('zone-header').innerText = closest.zone;
                    document.getElementById('zone-header').style.color = closest.color;
                    AudioEngine.trigger(closest.zone);
                }
                if (closest) {
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.strokeRect(closest.sx - 10 * this.zoom, closest.sy - 10 * this.zoom, 20 * this.zoom, 20 * this.zoom);
                }

                // Minimap
                this.minimapCtx.clearRect(0, 0, 80, 60);
                this.minimapCtx.fillStyle = '#222'; this.minimapCtx.fillRect(0, 0, 80, 60);
                if (closest) {
                    this.minimapCtx.fillStyle = '#fff';
                    this.minimapCtx.fillRect(closest.x * 3, closest.y * 2, 3, 2);
                }
            }
        };

        // --- RAYCASTER ENGINE (TEXT-URE v17) ---
        const RaycasterEngine = {
            canvas: document.getElementById('raycaster-canvas'),
            ctx: document.getElementById('raycaster-canvas').getContext('2d'),
            map: [], textures: [],
            player: { x: 12.5, y: 12.5, dirX: -1, dirY: 0, planeX: 0, planeY: 0.66 },
            keys: { w: false, a: false, s: false, d: false },
            config: { mapSize: 24, texSize: 64 },

            // New: Vision modes and joystick state
            visionMode: 'NORMAL', // NORMAL, PRISM, CONCAVE
            joystickLeft: { x: 0, y: 0 },
            joystickRight: { x: 0, y: 0 },
            collected: 0,
            totalCollectibles: 10,

            init() {
                // Generate Textures
                this.genTextures();
                // Generate Map
                this.map = new Array(24).fill(0).map((_, x) => new Array(24).fill(0).map((_, y) => {
                    const r = Math.sqrt((x - 11.5) ** 2 + (y - 11.5) ** 2);
                    // Create walls at roughly the ring boundaries
                    if (Math.abs(r - 3.5) < 0.8 || Math.abs(r - 6) < 0.8 || Math.abs(r - 9.5) < 0.8) return { type: 1, tex: Math.floor(Math.random() * this.textures.length) };
                    return { type: 0 };
                }));
                // Inputs
                window.addEventListener('keydown', e => {
                    if (e.key === 'w' || e.key === 'ArrowUp') this.keys.w = true;
                    if (e.key === 's' || e.key === 'ArrowDown') this.keys.s = true;
                    if (e.key === 'a' || e.key === 'ArrowLeft') this.keys.a = true;
                    if (e.key === 'd' || e.key === 'ArrowRight') this.keys.d = true;
                    if (e.key === ' ') this.scan();
                });
                window.addEventListener('keyup', e => {
                    if (e.key === 'w' || e.key === 'ArrowUp') this.keys.w = false;
                    if (e.key === 's' || e.key === 'ArrowDown') this.keys.s = false;
                    if (e.key === 'a' || e.key === 'ArrowLeft') this.keys.a = false;
                    if (e.key === 'd' || e.key === 'ArrowRight') this.keys.d = false;
                });

                // Initialize mobile joysticks
                this.initJoysticks();
            },

            initJoysticks() {
                const setupJoystick = (id, state, knobId) => {
                    const zone = document.getElementById(id);
                    const knob = document.getElementById(knobId);
                    if (!zone || !knob) return;

                    let active = false;
                    const rect = () => zone.getBoundingClientRect();

                    const update = (clientX, clientY) => {
                        const r = rect();
                        const cx = r.left + r.width / 2;
                        const cy = r.top + r.height / 2;
                        let dx = (clientX - cx) / (r.width / 2);
                        let dy = (clientY - cy) / (r.height / 2);
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len > 1) { dx /= len; dy /= len; }
                        state.x = dx;
                        state.y = dy;
                        knob.style.transform = `translate(calc(-50% + ${dx * 30}px), calc(-50% + ${dy * 30}px))`;
                    };

                    zone.addEventListener('touchstart', e => { active = true; update(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); });
                    zone.addEventListener('touchmove', e => { if (active) update(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); });
                    zone.addEventListener('touchend', () => { active = false; state.x = 0; state.y = 0; knob.style.transform = 'translate(-50%, -50%)'; });

                    zone.addEventListener('mousedown', e => { active = true; update(e.clientX, e.clientY); });
                    window.addEventListener('mousemove', e => { if (active) update(e.clientX, e.clientY); });
                    window.addEventListener('mouseup', () => { if (active) { active = false; state.x = 0; state.y = 0; knob.style.transform = 'translate(-50%, -50%)'; } });
                };

                setupJoystick('joystick-left', this.joystickLeft, 'joystick-left-knob');
                setupJoystick('joystick-right', this.joystickRight, 'joystick-right-knob');
            },

            setVision(mode) {
                this.visionMode = mode;
                ['NORMAL', 'PRISM', 'CONCAVE'].forEach(m => {
                    const btn = document.getElementById('vis-' + m.toLowerCase());
                    if (btn) {
                        btn.style.background = (m === mode) ? 'var(--ui-text)' : 'rgba(0,0,0,0.5)';
                        btn.style.color = (m === mode) ? '#000' : 'var(--color-secondary)';
                    }
                });
                AudioEngine.trigger(mode);
            },

            collect() {
                if (this.collected < this.totalCollectibles) {
                    this.collected++;
                    const hud = document.getElementById('collect-count');
                    if (hud) hud.innerText = `${this.collected} / ${this.totalCollectibles}`;
                    AudioEngine.rippleThud(0.8);
                    if (this.collected >= this.totalCollectibles) {
                        setTimeout(() => alert('COLLECTION COMPLETE! All text fragments gathered.'), 500);
                    }
                }
            },

            genTextures() {
                const text = "SING GODDESS THE WRATH OF ACHILLES PELEUS SON THE DESTRUCTIVE WRATH";
                const words = text.split(" ");
                words.forEach(w => {
                    const c = document.createElement('canvas');
                    c.width = 64; c.height = 64;
                    const x = c.getContext('2d');
                    x.fillStyle = "rgba(0, 40, 0, 0.8)"; // Wall background
                    x.fillRect(0, 0, 64, 64);
                    x.strokeStyle = "rgba(0, 255, 65, 0.5)";
                    x.strokeRect(0, 0, 64, 64); // Border
                    x.fillStyle = "#00ff41";
                    x.font = "bold 50px Courier New";
                    x.textAlign = "center"; x.textBaseline = "middle";
                    x.fillText(w[0], 32, 32);
                    this.textures.push(c);
                });
            },

            update() {
                const ms = 0.06, rs = 0.04;

                // MOVEMENT: Keyboard OR Left Joystick (forward/back)
                let moveForward = this.keys.w || this.joystickLeft.y < -0.3;
                let moveBack = this.keys.s || this.joystickLeft.y > 0.3;

                if (moveForward) {
                    this.player.x += this.player.dirX * ms;
                    this.player.y += this.player.dirY * ms;
                }
                if (moveBack) {
                    this.player.x -= this.player.dirX * ms;
                    this.player.y -= this.player.dirY * ms;
                }

                // ROTATION: Keyboard OR Right Joystick (or Left Joystick X for strafe-look)
                let rotRight = this.keys.d || this.joystickRight.x > 0.3 || this.joystickLeft.x > 0.3;
                let rotLeft = this.keys.a || this.joystickRight.x < -0.3 || this.joystickLeft.x < -0.3;

                if (rotRight) {
                    const oldDir = this.player.dirX;
                    this.player.dirX = this.player.dirX * Math.cos(-rs) - this.player.dirY * Math.sin(-rs);
                    this.player.dirY = oldDir * Math.sin(-rs) + this.player.dirY * Math.cos(-rs);
                    const oldPlane = this.player.planeX;
                    this.player.planeX = this.player.planeX * Math.cos(-rs) - this.player.planeY * Math.sin(-rs);
                    this.player.planeY = oldPlane * Math.sin(-rs) + this.player.planeY * Math.cos(-rs);
                }
                if (rotLeft) {
                    const oldDir = this.player.dirX;
                    this.player.dirX = this.player.dirX * Math.cos(rs) - this.player.dirY * Math.sin(rs);
                    this.player.dirY = oldDir * Math.sin(rs) + this.player.dirY * Math.cos(rs);
                    const oldPlane = this.player.planeX;
                    this.player.planeX = this.player.planeX * Math.cos(rs) - this.player.planeY * Math.sin(rs);
                    this.player.planeY = oldPlane * Math.sin(rs) + this.player.planeY * Math.cos(rs);
                }
            },

            render() {
                if (System.mode !== 'VOID') return;
                this.update();
                const w = this.canvas.width = window.innerWidth;
                const h = this.canvas.height = window.innerHeight;
                this.ctx.fillStyle = "#000"; this.ctx.fillRect(0, 0, w, h);

                // Floor Gradient
                const gradient = this.ctx.createLinearGradient(0, h / 2, 0, h);
                gradient.addColorStop(0, "#050505");
                gradient.addColorStop(1, "#1a1a1a");
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, h / 2, w, h / 2);

                for (let x = 0; x < w; x += 2) { // Low res
                    const camX = 2 * x / w - 1;
                    const rayDirX = this.player.dirX + this.player.planeX * camX;
                    const rayDirY = this.player.dirY + this.player.planeY * camX;

                    let mapX = Math.floor(this.player.x), mapY = Math.floor(this.player.y);
                    let sideDistX, sideDistY, perpDist;
                    let stepX, stepY, hit = 0, side;

                    const deltaDistX = Math.abs(1 / rayDirX), deltaDistY = Math.abs(1 / rayDirY);

                    if (rayDirX < 0) { stepX = -1; sideDistX = (this.player.x - mapX) * deltaDistX; }
                    else { stepX = 1; sideDistX = (mapX + 1.0 - this.player.x) * deltaDistX; }
                    if (rayDirY < 0) { stepY = -1; sideDistY = (this.player.y - mapY) * deltaDistY; }
                    else { stepY = 1; sideDistY = (mapY + 1.0 - this.player.y) * deltaDistY; }

                    while (hit === 0) {
                        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                        if (this.map[mapX] && this.map[mapX][mapY] && this.map[mapX][mapY].type > 0) hit = 1;
                        if (mapX < 0 || mapX >= 24 || mapY < 0 || mapY >= 24) { hit = 1; perpDist = 100; }
                    }

                    if (perpDist !== 100) {
                        if (side === 0) perpDist = (mapX - this.player.x + (1 - stepX) / 2) / rayDirX;
                        else perpDist = (mapY - this.player.y + (1 - stepY) / 2) / rayDirY;

                        const lineHeight = Math.floor(h / perpDist);
                        const drawStart = -lineHeight / 2 + h / 2;

                        let tex = this.textures[this.map[mapX][mapY].tex % this.textures.length];
                        this.ctx.globalAlpha = Math.min(1, 8 / perpDist); // Reduced Fog
                        this.ctx.drawImage(tex, x, drawStart, 2, lineHeight);
                        this.ctx.globalAlpha = 1;
                    }
                }
            },

            scan() {
                const txt = "SCANNED: ANCIENT METADATA " + Math.floor(Math.random() * 9999);
                document.getElementById('scanner-output').innerText = txt;
            },

            async generateFromBuffer() {
                document.getElementById('img-modal').classList.add('active');
                const canvas = document.getElementById('raycaster-canvas');
                const modalImg = document.getElementById('gen-image');
                const caption = document.getElementById('gen-caption');

                modalImg.style.opacity = 0;
                caption.innerText = "CAPTURING RETINAL BUFFER...";

                const apiKey = prompt("ENTER GEMINI API KEY FOR NEURAL LINK:"); // Simple input for now
                if (!apiKey) { caption.innerText = "LINK FAILED: MISSING KEY"; return; }

                caption.innerText = "TRANSMITTING TO ORACLE...";

                // Mocking the call structure based on original code, but simplified for this single-file
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-001:predict?key=${apiKey}`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ instances: [{ prompt: "Dark sci-fi landscape, matrix code, neon green, cinematic lighting" }], parameters: { sampleCount: 1 } })
                    });
                    const data = await response.json();
                    if (data.predictions) {
                        modalImg.src = `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
                        modalImg.style.opacity = 1;
                        caption.innerText = "NEURAL VISION ESTABLISHED.";
                    } else {
                        caption.innerText = "VISION ERROR.";
                    }
                } catch (e) { console.error(e); caption.innerText = "CONNECTION FAILURE."; }
            },

            speakBuffer() {
                const txt = document.getElementById('scanner-output').innerText;
                const u = new SpeechSynthesisUtterance(txt);
                window.speechSynthesis.speak(u);
            }
        };

        // --- CORE SYSTEM ---
        const System = {
            mode: 'GRID', // 'GRID' or 'VOID'

            init() {
                document.getElementById('boot-screen').style.display = 'none';
                AudioEngine.init();
                GridRenderer.init();
                RaycasterEngine.init();
                this.loop();
            },

            toggleMode() {
                this.mode = this.mode === 'GRID' ? 'VOID' : 'GRID';
                document.body.className = this.mode === 'GRID' ? 'active-mode-grid' : 'active-mode-void';
                const btn = document.getElementById('mode-toggle');
                btn.innerText = this.mode === 'GRID' ? 'ENTER VOID' : 'EXIT VOID';

                if (this.mode === 'VOID') AudioEngine.droneSynth.triggerAttack("C2");
                else AudioEngine.droneSynth.triggerRelease();
            },

            loop() {
                requestAnimationFrame(() => this.loop());
                if (this.mode === 'GRID') GridRenderer.loop();
                if (this.mode === 'VOID') RaycasterEngine.render();
            }
        };
    </script>
</body>

</html>