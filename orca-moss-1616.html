<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ORCA // SHIELD_DOSSIER_1616</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --color-bg: #050505;
            --color-primary: #72dec2;
            /* Orca Teal */
            --color-secondary: #666666;
            /* Orca Grey */
            --color-dim: #222222;
            --color-highlight: #ffffff;
            /* Orca White */
            --color-alert: #ff7272;
            /* Orca Red */
            --color-shift: #72a5ff;
            /* Orca Blue */
            --color-gold: #ffcc00;
            --font-stack: 'Courier New', Courier, monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-stack);
            overflow: hidden;
            background-image: radial-gradient(circle at center, #111 0%, #000 90%);
        }

        /* --- THE CHASSIS --- */
        .monitor-frame {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        /* --- CRT SCREEN --- */
        .crt-screen {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: transparent;
            color: var(--color-primary);
            /* Grid layout for remaining interactive elements */
            display: grid;
            grid-template-rows: 60px 1fr 100px;
            grid-template-columns: 1fr;
            z-index: 1;
        }

        /* CANVAS LAYER (Interactive) */
        #viz-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            /* Base layer */
            cursor: crosshair;
            touch-action: none;
        }

        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0.15;
            animation: flicker 0.1s infinite;
        }

        @keyframes flicker {
            0% {
                opacity: 0.15;
            }

            50% {
                opacity: 0.12;
            }

            100% {
                opacity: 0.18;
            }
        }

        /* --- BREATHING ANIMATION --- */
        @keyframes breathe {
            0% {
                opacity: 0.9;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.01);
            }

            100% {
                opacity: 0.9;
                transform: scale(1);
            }
        }

        /* --- UI ELEMENTS (Floating TUI) --- */

        /* HEADER (Canvas drawn now, but buttons remain) */
        .header-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            pointer-events: auto;
            display: flex;
            gap: 15px;
            animation: breathe 6s infinite ease-in-out;
        }

        .menu-toggle,
        .help-toggle {
            pointer-events: auto;
            cursor: pointer;
            color: var(--color-secondary);
            font-size: 1.2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(2px);
            transition: color 0.2s, border-color 0.2s;
        }

        .menu-toggle:hover,
        .help-toggle:hover {
            color: var(--color-primary);
            border-color: var(--color-primary);
        }

        /* SIDEBAR (Floating Text) */
        .sidebar {
            position: absolute;
            left: 20px;
            top: 80px;
            bottom: 120px;
            width: 220px;
            z-index: 30;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            font-size: 0.8rem;
            line-height: 1.4;
            color: var(--color-secondary);

            /* Transparent Container - "Display Surface" */
            background: transparent;
            pointer-events: none;
            animation: breathe 8s infinite ease-in-out;
            /* Syncs roughly with world */

            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), opacity 0.3s ease;
            transform: translateX(0);
        }

        @media (max-width: 768px) {
            .sidebar {
                opacity: 0;
                transform: translateX(-20px);
            }

            .sidebar.active {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .status-block {
            pointer-events: auto;
            padding-left: 0.5rem;
            border-left: 1px solid rgba(114, 222, 194, 0.3);
            /* Minimal background to let grid show through */
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.4) 0%, transparent 100%);
            padding: 5px 10px;
            margin-bottom: 5px;
        }

        .label {
            color: var(--color-primary);
            font-size: 0.65rem;
            display: block;
            margin-bottom: 0.1rem;
            font-weight: bold;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .value {
            font-size: 0.85rem;
            color: #fff;
            font-weight: bold;
            font-family: var(--font-stack);
        }

        .entity-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 1rem;
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 5px;
            pointer-events: auto;
        }

        /* TUI Buttons - Integrated Look */
        .entity-btn {
            background: rgba(0, 0, 0, 0.3);
            border: none;
            border-left: 2px solid transparent;
            color: var(--color-secondary);
            padding: 8px 10px;
            text-align: left;
            font-family: var(--font-stack);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .entity-btn:hover,
        .entity-btn.active {
            color: #fff;
            border-left-color: var(--color-primary);
            background: linear-gradient(90deg, rgba(114, 222, 194, 0.1) 0%, transparent 100%);
        }

        /* BOTTOM BAR (Floating Runes) */
        .controls-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            min-height: 100px;
            z-index: 30;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            pointer-events: none;
            padding-bottom: calc(45px + env(safe-area-inset-bottom, 0px));
            animation: breathe 7s infinite ease-in-out;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
        }

        .vector-group {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        .vector-label {
            font-size: 0.6rem;
            letter-spacing: 2px;
            opacity: 0.6;
            font-weight: bold;
            color: var(--color-highlight);
        }

        /* Rune Buttons - See-through Glass */
        .vector-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--color-secondary);
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-stack);
            transition: all 0.2s;
            backdrop-filter: blur(2px);
        }

        .vector-btn i {
            font-size: 1.4rem;
            font-style: normal;
            font-weight: bold;
        }

        .vector-group:hover .vector-btn {
            border-color: var(--color-highlight);
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .vector-group:active .vector-btn {
            transform: scale(0.95);
        }

        .btn-goal i {
            color: var(--color-gold);
        }

        .btn-obstacle i {
            color: var(--color-alert);
        }

        .btn-shift i {
            color: var(--color-shift);
        }

        /* HUD / MINIMAP */
        .hud-overlay {
            position: absolute;
            bottom: 100px;
            right: 10px;
            z-index: 25;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        .hud-panel {
            background: transparent;
            text-shadow: 0 1px 2px #000;
            padding: 0;
            font-size: 0.65rem;
            color: var(--color-secondary);
            pointer-events: auto;
        }

        .hud-minimap-container {
            width: 80px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            pointer-events: auto;
            position: relative;
            backdrop-filter: blur(2px);
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .toggle-mode-btn {
            background: transparent;
            color: #888;
            border: 1px solid #333;
            padding: 4px 8px;
            font-size: 0.65rem;
            cursor: pointer;
            font-family: var(--font-stack);
            pointer-events: auto;
            backdrop-filter: blur(4px);
            transition: 0.2s;
        }

        .toggle-mode-btn:hover {
            color: #fff;
            border-color: #666;
        }

        .toggle-mode-btn.active {
            color: var(--color-gold);
            border-color: var(--color-gold);
            background: rgba(255, 204, 0, 0.1);
        }

        /* --- NEURAL INTERFACE (Context Menu) --- */
        #neural-context-menu {
            position: absolute;
            display: none;
            width: 240px;
            /* Glass Terminal Look */
            background: rgba(5, 5, 5, 0.85);
            border: 1px solid var(--color-primary);
            border-top: 3px solid var(--color-primary);
            backdrop-filter: blur(12px);
            z-index: 10000;
            font-family: var(--font-stack);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            padding: 0;
            color: #fff;

            /* Rising Animation */
            transform-origin: bottom center;
            animation: riseUp 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes riseUp {
            from {
                transform: scale(0.9) translateY(20px);
                opacity: 0;
            }

            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        .neural-header {
            display: flex;
            justify-content: space-between;
            background: rgba(114, 222, 194, 0.15);
            padding: 8px 10px;
            font-size: 0.7rem;
            color: var(--color-primary);
            font-weight: bold;
        }

        .neural-options {
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 4px;
        }

        .patch-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: #aaa;
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.75rem;
            font-family: var(--font-stack);
            transition: 0.2s;
        }

        .patch-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-color: var(--color-primary);
        }

        .patch-icon {
            font-weight: bold;
            width: 20px;
            display: inline-block;
            text-align: center;
            margin-right: 5px;
        }

        .patch-transform .patch-icon {
            color: var(--color-primary);
        }

        .patch-branch .patch-icon {
            color: var(--color-gold);
        }

        .patch-seed .patch-icon {
            color: var(--color-shift);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 4px 8px;
            font-size: 10px;
            pointer-events: none;
            z-index: 1001;
            border: 1px solid #444;
            display: none;
        }

        /* Boot & Help modals kept minimal */
        #boot-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 30000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
            color: #72dec2;
        }

        #help-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 400px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #72dec2;
            padding: 20px;
            z-index: 20000;
            font-family: 'Courier New', monospace;
            color: #fff;
            backdrop-filter: blur(10px);
        }
    </style>
</head>

<body>

    <!-- BOOT SCREEN -->
    <div id="boot-screen">
        <div
            style="font-size: 1.5rem; letter-spacing: 4px; margin-bottom: 20px; animation: flicker 0.2s infinite alternate;">
            ORCA // SHIELD_DOSSIER</div>
        <div style="font-size: 0.7rem; color: #888; margin-bottom: 30px;">CASE #HOM-990-26 | Det. W.F. Hartsoe III</div>
        <button onclick="initializeSystem()"
            style="background: transparent; color: #fff; border: 1px solid #72dec2; padding: 15px 30px; font-family: inherit; font-size: 1rem; cursor: pointer;">INITIALIZE
            SYSTEM</button>
    </div>

    <div class="monitor-frame">
        <div class="crt-overlay"></div>
        <div class="crt-screen">
            <canvas id="viz-canvas"></canvas>
            <div id="tooltip" class="tooltip"></div>

            <!-- HELP MODAL -->
            <div id="help-modal">
                <div
                    style="display:flex; justify-content:space-between; margin-bottom:15px; border-bottom:1px solid #333; padding-bottom:10px;">
                    <span style="color:#daa520; font-weight:bold;">CASE FILE: HOM-990-26</span>
                    <span onclick="toggleHelp()" style="cursor:pointer;">âœ•</span>
                </div>
                <div style="font-size:0.8rem; line-height:1.6; color:#ccc;">
                    <div style="margin-bottom:10px;"><strong style="color:#ffcc00">â˜‰ SCAN:</strong> View Zone
                        Description & Forensic Note</div>
                    <div style="margin-bottom:10px;"><strong style="color:#ff7272">âš‘ FLAG:</strong> Show Evidence
                        Collection Status</div>
                    <div style="margin-bottom:10px;"><strong style="color:#72a5ff">â˜° LOG:</strong> Generate CSPR
                        Evidence Report</div>
                    <div style="margin-bottom:10px;"><strong style="color:#72dec2">TAP ZONE:</strong> Navigate &
                        Auto-Collect Evidence</div>
                    <div><strong style="color:#4682b4">LONG PRESS:</strong> Neural Patch Interface</div>
                </div>
            </div>

            <!-- NEURAL INTERFACE -->
            <div id="neural-context-menu">
                <div class="neural-header">
                    <span>PATCH OPERATIONS</span>
                    <span style="cursor:pointer" onclick="closeNeuralMenu()">âœ•</span>
                </div>
                <div id="cells-count-container"
                    style="padding: 5px 10px; font-size: 0.65rem; color: #888; border-bottom: 1px solid #222;">
                    SELECTED: <span id="ctx-cells-count" style="color: #72dec2;">0</span> CELLS
                </div>
                <div class="neural-options">
                    <button class="patch-btn patch-transform" onclick="applyPatch('TRANSFORM')">
                        <span><span class="patch-icon">T</span> TRANSFORM</span>
                    </button>
                    <button class="patch-btn patch-branch" onclick="applyPatch('BRANCH')">
                        <span><span class="patch-icon">B</span> BRANCH</span>
                    </button>
                    <button class="patch-btn patch-seed" onclick="applyPatch('SEED')">
                        <span><span class="patch-icon">S</span> SEED</span>
                    </button>
                    <div style="padding: 5px 0; display: flex; gap: 5px;">
                        <input type="text" id="custom-prompt" placeholder="CMD..."
                            style="background:rgba(255,255,255,0.1); border:none; color:#fff; padding:6px; font-family:inherit; font-size:0.7rem; flex-grow:1;">
                        <button onclick="applyCustom()"
                            style="background:#72dec2; border:none; color:#000; padding:6px 10px; font-family:inherit; font-size:0.7rem; cursor:pointer; font-weight:bold;">></button>
                    </div>
                </div>
            </div>

            <!-- HEADER CONTROLS (Floating) -->
            <div class="header-controls">
                <button class="help-toggle" onclick="toggleHelp()">?</button>
                <button class="menu-toggle" onclick="toggleSidebar()">â‰¡</button>
            </div>

            <!-- SIDEBAR (Floating Text) -->
            <div class="sidebar" id="sidebar">
                <div class="status-block">
                    <span class="label">STATUS</span>
                    <span class="value" style="color: var(--color-primary)">ONLINE</span>
                </div>
                <div class="status-block">
                    <span class="label">ZONE</span>
                    <span class="value" id="ui-entity" style="color: #fff">--</span>
                </div>
                <div class="entity-list" id="entity-list-container"></div>
            </div>

            <!-- HUD Overlay -->
            <div class="hud-overlay">
                <button class="toggle-mode-btn" onclick="renderer.resetView()">RECENTER</button>
                <button id="mode-btn" class="toggle-mode-btn" onclick="renderer.toggleMode()">NAVIGATE</button>
                <div class="hud-panel" id="ui-coords">0,0</div>
                <div class="hud-minimap-container">
                    <canvas id="minimap-canvas"></canvas>
                </div>
            </div>

            <!-- CONTROLS (Floating Runes) -->
            <div class="controls-bar">
                <div class="vector-group" onclick="engine.triggerVector('GOAL')">
                    <div class="vector-btn btn-goal"><i>â˜‰</i></div>
                    <span class="vector-label">SCAN</span>
                </div>
                <div class="vector-group" onclick="engine.triggerVector('OBSTACLE')">
                    <div class="vector-btn btn-obstacle"><i>âš‘</i></div>
                    <span class="vector-label">FLAG</span>
                </div>
                <div class="vector-group" onclick="engine.triggerVector('SHIFT')">
                    <div class="vector-btn btn-shift"><i>â˜°</i></div>
                    <span class="vector-label">LOG</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- AUDIO ENGINE ---
        const AudioEngine = {
            initialized: false,
            thudSynth: null,
            noiseSynth: null,

            async init() {
                if (this.initialized) return;
                try {
                    await Tone.start();
                    this.thudSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.1, octaves: 1.5, oscillator: { type: "sine" },
                        envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }
                    }).toDestination();
                    this.thudSynth.volume.value = -10;

                    this.noiseSynth = new Tone.NoiseSynth({
                        noise: { type: "pink" },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0 }
                    }).toDestination();
                    this.noiseSynth.volume.value = -25;

                    this.initialized = true;
                    console.log("AUDIO READY");
                } catch (e) { console.error("AUDIO INIT FAILED", e); }
            },

            lastThudTime: 0,
            thud(vel = 0.5, note = "C1") {
                if (!this.initialized) return;

                const now = Tone.now();
                if (now - this.lastThudTime < 0.05) return;

                this.lastThudTime = now;
                this.thudSynth.triggerAttackRelease(note, "32n", now, vel);
                if (vel > 0.4) this.noiseSynth.triggerAttackRelease("32n", now, vel * 0.3);
            }
        };

        // --- UTILS ---
        function initializeSystem() {
            const boot = document.getElementById('boot-screen');
            boot.style.transition = 'opacity 0.8s ease';
            boot.style.opacity = '0';
            AudioEngine.init();
            setTimeout(() => {
                boot.style.display = 'none';
                engine.init();
            }, 800);
        }

        function toggleSidebar() {
            const sb = document.getElementById('sidebar');
            sb.classList.toggle('active');
        }

        function toggleHelp() {
            const modal = document.getElementById('help-modal');
            modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
        }

        function closeNeuralMenu() {
            document.getElementById('neural-context-menu').style.display = 'none';
        }

        function applyPatch(type) {
            const prompt = document.getElementById('custom-prompt').value;
            engine.processPatch(type, prompt);
            closeNeuralMenu();
        }

        function applyCustom() {
            applyPatch('TRANSFORM');
        }

        // --- SHIELD OF ACHILLES FORENSIC DATA ---

        // Zone detection based on distance from center (concentric rings)
        function getZoneFromDistance(dist, maxDist) {
            const norm = dist / maxDist;
            if (norm < 0.12) return "COSMOS";      // Inner 12%
            if (norm < 0.30) return "LITIGATION";  // 12-30%
            if (norm < 0.50) return "LABOR";       // 30-50%
            if (norm < 0.75) return "LIONS";       // 50-75%
            return "OCEAN";                         // 75-100%
        }

        function getZoneColor(zoneName) {
            const z = SHIELD_ZONES[zoneName];
            return z ? z.color : "#333";
        }

        const SHIELD_ZONES = {
            COSMOS: {
                id: "cosmos", name: "ZONE 0: COSMOS", ring: 0, color: "#daa520", icon: "â—‰",
                classification: "Environmental Background / Datum Point",
                environment: { poe: "None - sealed center", ambient: "Eternal stillness", transient: "Celestial patterns" },
                patterns: { observation: "High-relief gold: Earth, Sea, Sky, constellations", orientation: "Central 15cm boss", condition: "Pristine", collection: "Reference only" },
                forensicNote: "The 'witness' - sees all, touched by none. FROZEN TIMESTAMP."
            },
            LITIGATION: {
                id: "litigation", name: "ZONE 1A: CITY OF PEACE", ring: 1, color: "#8b0000", icon: "âš–",
                classification: "Comparative Behavioral / Motive",
                environment: { poe: "Public agora", ambient: "High systemic tension", transient: "Vocal testimony in metal grain" },
                patterns: { observation: "Two litigants in adversarial posture", orientation: "Symmetric around gold talents", condition: "Defense posture", collection: "3D gesture scan" },
                forensicNote: "MOTIVE ESTABLISHED. Two talents of gold. Cycle perpetuates."
            },
            AMBUSH: {
                id: "ambush", name: "ZONE 1B: CITY AT WAR", ring: 1, color: "#a52a2a", icon: "âš”",
                classification: "Primary Crime Scene",
                environment: { poe: "Watering hole choke point", ambient: "Siege conditions", transient: "Scout approach vectors" },
                patterns: { observation: "Red copper = splatter pattern", orientation: "Radial from riverbank", condition: "Preserved in grain", collection: "Isotope analysis" },
                forensicNote: "PRIMARY MO of suspect (WAR). Area of Origin confirmed."
            },
            LABOR: {
                id: "labor", name: "ZONE 2: TEMENOS (Sacred Fields)", ring: 2, color: "#2e8b57", icon: "ðŸŒ¾",
                classification: "Timeline Correlation",
                environment: { poe: "Open field", ambient: "Harvest season", transient: "Grain at 23Â° angle" },
                patterns: { observation: "Tin sickles, king with scepter", orientation: "GRAIN ANGLE = BODY ANGLE Zone 1-B", condition: "Active harvest", collection: "Fiber trace" },
                forensicNote: "TEMPORAL BASELINE - simultaneity of crime and life."
            },
            LIONS: {
                id: "lions", name: "ZONE 3: NEPOS (Pastureland)", ring: 3, color: "#cd853f", icon: "ðŸ¦",
                classification: "Biological / Predatory Profiling",
                environment: { poe: "Valley with stream", ambient: "Pastoral â†’ predatory", transient: "Dog bark terror frequency" },
                patterns: { observation: "Two lions dragging bull", orientation: "Drag toward perimeter", condition: "Hide rent open, gouging", collection: "Wound morphology scan" },
                bioForensics: { victim: "Gold bull - entrails visible", attackerProfile: "LION A=Achilles, LION B=Hector" },
                forensicNote: "Bull = PATROCLUS. ENTROPY documented. Most visceral zone."
            },
            OCEAN: {
                id: "ocean", name: "ZONE 4: OKEANOS (Rim)", ring: 4, color: "#4682b4", icon: "ã€°",
                classification: "Boundary / Jurisdictional / Chain of Custody",
                environment: { poe: "NONE - complete encirclement", ambient: "Recursive currents", transient: "Nothing escapes" },
                patterns: { observation: "Mighty River Ocean", orientation: "360Â° sealed perimeter", condition: "No egress", collection: "Full photogrammetry" },
                forensicNote: "'LOCKED ROOM.' Case CLOSED by geography. All evidence contained."
            }
        };

        const EVIDENCE_CATALOG = {
            "001": {
                itemNo: "#001", name: "Central Boss (Omphalos)", zone: "COSMOS",
                entityClass: "Environmental Baseline",
                observation: "High-relief gold inlay depicting celestial bodies",
                orientation: "Central 15cm radius boss, datum point",
                condition: "Pristine - un-struck during confrontation",
                collection: "N/A - reference only",
                relationship: "The 'witness' that sees everything but remains untouched"
            },
            "002": {
                itemNo: "#002", name: "Two Talents of Gold", zone: "LITIGATION",
                entityClass: "Currency / Motive Object",
                observation: "99.8% purity, circular cast, no scuffing",
                orientation: "Exact geometric center between litigants",
                condition: "Untouched - the contested prize",
                collection: "Photograph in situ",
                relationship: "MOTIVE. Positioned at exact geometric center."
            },
            "003": {
                itemNo: "#003", name: "Herald's Staves", zone: "LITIGATION",
                entityClass: "Instrument of Jurisdiction",
                observation: "1.5m polished wood, gold leaf texture",
                orientation: "Transferred between elders for speech rights",
                condition: "Grip-wear indicates frequent transfer",
                collection: "3D scan for handprint-wear patterns",
                relationship: "JURISDICTION. Systemic cycle of violence."
            },
            "004": {
                itemNo: "#004", name: "Red Copper Swab", zone: "AMBUSH",
                entityClass: "Bio-Trace Simulation",
                observation: "Red-tinted copper inlay concentrated at riverbank",
                orientation: "Radial splatter pattern from impact zone",
                condition: "Splatter preserved in metal grain",
                collection: "Micro-shavings for isotope analysis",
                relationship: "Primary MO of suspect (WAR)"
            },
            "005": {
                itemNo: "#005", name: "Tin Sickle Fragment", zone: "LABOR",
                entityClass: "Agricultural Tool",
                observation: "Curved blade, sharpened tin edge",
                orientation: "Grain falling angle matches body angle in Zone 1",
                condition: "Use-wear consistent with harvest",
                collection: "Trace fiber analysis",
                relationship: "TEMPORAL BASELINE - simultaneity proof"
            },
            "006": {
                itemNo: "#006", name: "Gold Bull Fragments", zone: "LIONS",
                entityClass: "Biological Specimen (simulated)",
                observation: "Hide 'rent open', dark blood and entrails visible",
                orientation: "Drag vector toward perimeter",
                condition: "Significant gouging - dental/claw pattern",
                collection: "High-res 3D surface scan",
                relationship: "ENTROPY documentation. Most visceral zone."
            },
            "007": {
                itemNo: "#007", name: "Tide Pattern Sample", zone: "OCEAN",
                entityClass: "Boundary Marker",
                observation: "Recursive current patterns in bronze",
                orientation: "Outermost rim, complete encirclement",
                condition: "No break in the loop detected",
                collection: "Photogrammetry scan",
                relationship: "LOCKED ROOM. Proves closed-system investigation."
            }
        };

        let COLLECTED_EVIDENCE = [];
        let CURRENT_ZONE = "COSMOS";

        function collectEvidence(id) {
            if (!COLLECTED_EVIDENCE.includes(id)) {
                COLLECTED_EVIDENCE.push(id);
                AudioEngine.thud(0.9, "G2");
                return true;
            }
            return false;
        }

        function getCSPRReport(id) {
            const ev = EVIDENCE_CATALOG[id];
            if (!ev) return "NO DATA";
            return `â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ CSPR EVIDENCE LOG  [CASE: HOM-990]â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 Item ${ev.itemNo}: ${ev.name}
 Class: ${ev.entityClass}
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 OBSERVATION:
 ${ev.observation}
 ORIENTATION:
 ${ev.orientation}
 CONDITION:
 ${ev.condition}
 COLLECTION:
 ${ev.collection}
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 RELATIONSHIP TO CASE:
 ${ev.relationship}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
        }

        //Legacy compatibility
        const LATENT_LIBRARY = {
            "shield_of_achilles": {
                "id": "shield_of_achilles", "name": "SHIELD OF ACHILLES",
                "entities": Object.values(SHIELD_ZONES).map(z => ({
                    id: z.id, name: z.name, icon: z.icon, palette: z.icon + "â—‹â—â—Ž", color: z.color
                }))
            }
        };

        // --- AI CONFIGURATION ---
        const AI_CONFIG = {
            useLocalLLM: true,
            localLLMModel: "llama3",
            geminiModel: "gemini-1.5-flash",
            // System instructions for Forensic/Evidence generation
            systemInstruction: `
                You are a Forensic Investigator analyzing a digital crime scene (The Shield of Achilles).
                User input describes a trace or phenomenon.
                You must output a JSON object with:
                1. "chars": A string of 2-5 characters representing this (e.g. "BLOOD", "??!!").
                2. "color": A hex code suitable for this evidence.
                Output JSON ONLY. No markdown.
            `
        };

        // --- UNIFIED LLM CALLER ---
        async function callLLM(prompt) {
            try {
                if (AI_CONFIG.useLocalLLM) return await callLocalLLM(prompt);
                return await callGemini(prompt);
            } catch (e) {
                console.warn("AI_FAIL:", e);
                return null;
            }
        }

        async function callLocalLLM(prompt) {
            const response = await fetch('http://localhost:11434/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: AI_CONFIG.localLLMModel,
                    messages: [
                        { role: "system", content: AI_CONFIG.systemInstruction },
                        { role: "user", content: prompt }
                    ],
                    stream: false
                })
            });
            if (!response.ok) throw new Error("Ollama Error");
            const data = await response.json();
            return JSON.parse(data.message.content.replace(/```json|```/g, '').trim());
        }

        async function callGemini(prompt) {
            const apiKey = localStorage.getItem('GEMINI_API_KEY') || "";
            if (!apiKey) throw new Error("No Gemini API Key");

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${AI_CONFIG.geminiModel}:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: AI_CONFIG.systemInstruction }] }
                })
            });
            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            return JSON.parse(text.replace(/```json|```/g, '').trim());
        }

        // --- ENGINE ---
        class RipplesEngine {
            constructor() {
                this.state = {
                    scenarioId: 'shield_of_achilles',
                    zoneId: 'cosmos',
                    ripples: [],
                    activeAgents: []
                };
            }

            init() {
                this.renderUI();
                this.spawnRipple("CASE.OPEN", "#daa520", 0, 0, 150, 30, "â—‰â—‹â—");
            }

            getZone(id) {
                return Object.values(SHIELD_ZONES).find(z => z.id === id);
            }

            getZonePalette(id) {
                const zone = this.getZone(id);
                return zone ? zone.icon + "â—‹â—â—Ž" : ".....";
            }

            selectZone(id) {
                this.state.zoneId = id;
                CURRENT_ZONE = id.toUpperCase();
                this.renderUI();
                const zone = this.getZone(id);
                if (zone) {
                    AudioEngine.thud(0.7, "C2");
                    this.spawnRipple(`[${zone.name}]`, zone.color, renderer.panX * -0.05, renderer.panY * -0.05, 100, 20, zone.icon + "â—Ž");

                    // Auto-collect evidence for this zone
                    const zoneEvidence = Object.entries(EVIDENCE_CATALOG).find(([k, v]) => v.zone === CURRENT_ZONE);
                    if (zoneEvidence) {
                        const wasNew = collectEvidence(zoneEvidence[0]);
                        if (wasNew) {
                            this.spawnRipple(`EVIDENCE ${zoneEvidence[1].itemNo}`, "#00ff00", 0, 0, 200, 25, "â˜†â˜…");
                        }
                    }
                }
            }

            triggerVector(type) {
                let color = "#fff";
                let chars = "";
                const zonePalette = this.state.zoneId ? this.getZonePalette(this.state.zoneId) : "..";

                if (type === 'GOAL') {
                    color = "#ffcc00"; chars = zonePalette + ">>";
                    AudioEngine.thud(0.9, "G1");
                    // Show zone description
                    const zone = this.getZone(this.state.zoneId);
                    if (zone) alert(`ZONE DESCRIPTION:\n\n${zone.description}\n\nFORENSIC NOTE:\n${zone.forensicNote}`);
                }
                if (type === 'OBSTACLE') {
                    color = "#ff7272"; chars = zonePalette + "##";
                    AudioEngine.thud(0.6, "D1");
                    // Show collected evidence count
                    alert(`EVIDENCE COLLECTED: ${COLLECTED_EVIDENCE.length}/7\n\nItems: ${COLLECTED_EVIDENCE.map(id => EVIDENCE_CATALOG[id]?.name).join(', ') || 'None'}`);
                }
                if (type === 'SHIFT') {
                    color = "#72a5ff"; chars = zonePalette + "~";
                    AudioEngine.thud(0.5, "E2");
                    // Show CSPR report for current zone
                    const zoneEvidence = Object.entries(EVIDENCE_CATALOG).find(([k, v]) => v.zone === CURRENT_ZONE);
                    if (zoneEvidence) alert(getCSPRReport(zoneEvidence[0]));
                }

                this.spawnRipple(type, color, 0, 0, 800, 45, chars);
            }

            async processPatch(type, prompt) {
                const targets = Array.from(renderer.selectedCells);
                if (targets.length === 0) return;

                let chars = ".";
                let color = "#fff";
                const zone = this.getZone(this.state.zoneId);

                if (type === 'BRANCH') {
                    chars = zone ? zone.icon : "Yy"; color = zone ? zone.color : "#ffcc00";
                } else if (type === 'SEED') {
                    chars = "âš–âš”ðŸŒ¾ðŸ¦ã€°"; color = "#72a5ff";
                    const start = targets[Math.floor(Math.random() * targets.length)];
                    const [sx, sy] = start.split(',').map(Number);
                    this.state.activeAgents.push({
                        x: sx, y: sy, type: 'INVESTIGATOR', color: '#72a5ff', life: 1000
                    });
                } else {
                    // LLM Call
                    const p = (prompt || "").toLowerCase();
                    renderer.drawFloatingText("AI: ANALYZING...", 100, 100, "#72dec2", 10);

                    const aiResult = await callLLM(p);
                    if (aiResult) {
                        chars = aiResult.chars || "??";
                        color = aiResult.color || "#fff";
                    } else {
                        // Fallback
                        if (p.includes("blood")) { chars = "â—â—‰"; color = "#8b0000"; }
                        else if (p.includes("gold")) { chars = "â—‰â—‹"; color = "#daa520"; }
                        else if (p.includes("ocean")) { chars = "ã€°~"; color = "#4682b4"; }
                        else { chars = "###"; color = "#72dec2"; }
                    }
                }

                targets.forEach(key => {
                    const [x, y] = key.split(',').map(Number);
                    if (renderer.gridState[y] && renderer.gridState[y][x]) {
                        renderer.gridState[y][x] = {
                            char: chars.charAt(Math.floor(Math.random() * chars.length)),
                            color: color
                        };
                    }
                });

                this.spawnRipple(`${type}.EXE`, color, 0, 0, 120, 40, chars);
                AudioEngine.thud(0.8, "A1");
                renderer.selectedCells.clear();
            }

            spawnRipple(text, color, x, y, life, strength, palette = ".....") {
                this.state.ripples.push({
                    id: Math.random(), text, color, x, y, born: Date.now(),
                    lifeMax: life, life: 0, radius: 0, strength, palette
                });
            }

            renderUI() {
                const scenario = LATENT_LIBRARY['shield_of_achilles'];
                const listContainer = document.getElementById('entity-list-container');
                const uiEntity = document.getElementById('ui-entity');

                const zone = this.getZone(this.state.zoneId);
                uiEntity.innerText = zone ? zone.name : "--";
                uiEntity.style.color = zone ? zone.color : "#fff";

                listContainer.innerHTML = '';

                // Add zone buttons
                Object.values(SHIELD_ZONES).forEach(z => {
                    const btn = document.createElement('button');
                    btn.className = `entity-btn ${z.id === this.state.zoneId ? 'active' : ''}`;
                    btn.style.borderLeftColor = z.color;
                    btn.innerHTML = `<span class="entity-icon" style="color:${z.color}">${z.icon}</span> ${z.name}`;
                    btn.onclick = () => {
                        this.selectZone(z.id);
                        if (window.innerWidth <= 768) toggleSidebar();
                    };
                    listContainer.appendChild(btn);
                });

                // Add evidence counter
                const counter = document.createElement('div');
                counter.style.cssText = 'margin-top:10px; padding:8px; background:rgba(0,255,0,0.1); border:1px solid #0f0; font-size:0.7rem; color:#0f0;';
                counter.innerHTML = `EVIDENCE: ${COLLECTED_EVIDENCE.length}/7`;
                listContainer.appendChild(counter);
            }
        }

        // --- RENDERER ---
        class HybridGridRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.minimapCanvas = document.getElementById('minimap-canvas');
                this.ctxMini = this.minimapCanvas.getContext('2d');

                this.gridSize = 64;
                this.baseIsoWidth = 16; this.baseIsoHeight = 8;
                this.gridState = new Array(this.gridSize).fill(0).map(() => new Array(this.gridSize).fill(null).map(() => ({ char: null, color: null })));

                this.selectedCells = new Set();
                this.zoom = 1.0; this.targetZoom = 1.0;
                this.panX = 0; this.panY = 0;

                this.mode = 'NAVIGATE';

                this.touchStartDist = 0;
                this.isDragging = false;
                this.lastX = 0; this.lastY = 0;
                this.longPressTimer = null;

                this.hoverCell = null;
                this.time = 0;
                this.lastTap = 0;

                window.addEventListener('resize', () => this.resize());
                this.resize();
                this.bindEvents();
                requestAnimationFrame(() => this.loop());
            }

            resize() {
                this.canvas.width = this.canvas.parentElement.offsetWidth;
                this.canvas.height = this.canvas.parentElement.offsetHeight;
                this.cx = this.canvas.width / 2; this.cy = this.canvas.height / 2;
                this.minimapCanvas.width = this.minimapCanvas.parentElement.offsetWidth;
                this.minimapCanvas.height = this.minimapCanvas.parentElement.offsetHeight;

                if (window.innerWidth <= 768) {
                    this.gridSize = 32;
                    this.baseIsoWidth = 24;
                    this.baseIsoHeight = 12;
                    this.targetZoom = 1.2;
                    if (this.gridState.length !== this.gridSize) {
                        this.gridState = new Array(this.gridSize).fill(0).map(() => new Array(this.gridSize).fill(null).map(() => ({ char: null, color: null })));
                    }
                }
            }

            toggleMode() {
                this.mode = this.mode === 'NAVIGATE' ? 'PAINT' : 'NAVIGATE';
                const btn = document.getElementById('mode-btn');
                if (btn) {
                    btn.innerText = this.mode;
                    if (this.mode === 'PAINT') btn.classList.add('active');
                    else btn.classList.remove('active');
                }
            }

            resetView() {
                this.panX = 0;
                this.panY = 0;
                this.targetZoom = window.innerWidth <= 768 ? 1.2 : 1.0;
                engine.spawnRipple("RESET", "#fff", 0, 0, 50, 10);
            }

            openContextMenu(x, y) {
                if (this.selectedCells.size === 0 && this.hoverCell) {
                    this.selectedCells.add(`${this.hoverCell.gridX},${this.hoverCell.gridY}`);
                }

                const menu = document.getElementById('neural-context-menu');
                const count = document.getElementById('ctx-cells-count');

                if (menu) menu.style.display = 'block';
                if (count) count.innerText = this.selectedCells.size;

                let mx = x; let my = y;
                if (mx + 260 > window.innerWidth) mx = window.innerWidth - 270;
                if (my + 200 > window.innerHeight) my = window.innerHeight - 210;

                if (menu) {
                    menu.style.left = mx + 'px';
                    menu.style.top = my + 'px';
                }
            }

            handleInputStart(x, y, isShift) {
                this.isDragging = true;
                this.lastX = x; this.lastY = y;

                if (this.mode === 'PAINT' || isShift) {
                    if (this.hoverCell) {
                        this.selectedCells.add(`${this.hoverCell.gridX},${this.hoverCell.gridY}`);
                    }
                }
            }

            handleInputMove(x, y, isShift) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos = { x: x - rect.left, y: y - rect.top };

                if (this.isDragging) {
                    if (this.mode === 'PAINT' || isShift) {
                        if (this.hoverCell) this.selectedCells.add(`${this.hoverCell.gridX},${this.hoverCell.gridY}`);
                    } else {
                        this.panX += x - this.lastX;
                        this.panY += y - this.lastY;
                    }
                }
                this.lastX = x; this.lastY = y;
            }

            bindEvents() {
                this.canvas.addEventListener('mousedown', e => {
                    if (e.button === 2) return;
                    const now = Date.now();
                    if (now - this.lastTap < 300) { this.resetView(); return; }
                    this.lastTap = now;
                    this.handleInputStart(e.clientX, e.clientY, e.shiftKey);
                });

                window.addEventListener('mousemove', e => {
                    this.handleInputMove(e.clientX, e.clientY, e.shiftKey);
                });

                window.addEventListener('mouseup', () => this.isDragging = false);

                this.canvas.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    this.openContextMenu(e.clientX, e.clientY);
                });

                this.canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    this.targetZoom = Math.min(Math.max(0.3, this.targetZoom - e.deltaY * 0.001), 4.0);
                });

                // TOUCH
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const now = Date.now();
                    if (e.touches.length === 1 && now - this.lastTap < 300) { this.resetView(); return; }
                    this.lastTap = now;

                    if (e.touches.length === 1) {
                        const t = e.touches[0];
                        this.handleInputStart(t.clientX, t.clientY, false);

                        this.longPressTimer = setTimeout(() => {
                            this.isDragging = false;
                            this.openContextMenu(t.clientX, t.clientY);
                        }, 600);
                    }
                    else if (e.touches.length === 2) {
                        this.touchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    if (Math.hypot(e.touches[0].clientX - this.lastX, e.touches[0].clientY - this.lastY) > 10) clearTimeout(this.longPressTimer);

                    if (e.touches.length === 1) {
                        this.handleInputMove(e.touches[0].clientX, e.touches[0].clientY, false);
                    }
                    else if (e.touches.length === 2) {
                        clearTimeout(this.longPressTimer);
                        const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                        const delta = dist - this.touchStartDist;
                        this.targetZoom = Math.min(Math.max(0.3, this.targetZoom + delta * 0.005), 4.0);
                        this.touchStartDist = dist;
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchend', () => {
                    this.isDragging = false; clearTimeout(this.longPressTimer); this.mousePos = null;
                });
            }

            drawMinimap() {
                const ctx = this.ctxMini;
                const w = this.minimapCanvas.width; const h = this.minimapCanvas.height;
                ctx.clearRect(0, 0, w, h);
                const centerX = w / 2; const centerY = h / 2;

                ctx.fillStyle = '#ffcc00';
                this.selectedCells.forEach(key => {
                    const [gx, gy] = key.split(',').map(Number);
                    const mx = centerX + (gx - this.gridSize / 2) * 2; const my = centerY + (gy - this.gridSize / 2) * 2;
                    ctx.fillRect(mx, my, 2, 2);
                });

                engine.state.activeAgents.forEach(a => {
                    const mx = centerX + (a.x - this.gridSize / 2) * 2; const my = centerY + (a.y - this.gridSize / 2) * 2;
                    ctx.fillStyle = a.color; ctx.fillRect(mx, my, 3, 3);
                });

                const viewW = (w * 0.8) / this.zoom; const viewH = (h * 0.8) / this.zoom;
                const viewX = centerX - (this.panX * 0.1) - viewW / 2; const viewY = centerY - (this.panY * 0.1) - viewH / 2;
                ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1; ctx.strokeRect(viewX, viewY, viewW, viewH);
            }

            drawFloatingText(text, x, y, color = "#fff", fontSize = 12) {
                this.ctx.fillStyle = color;
                this.ctx.font = `bold ${fontSize}px 'Courier New'`;
                this.ctx.fillText(text, x, y);
            }

            loop() {
                try {
                    this.time += 0.005;
                    this.zoom += (this.targetZoom - this.zoom) * 0.1;

                    // Render Background
                    this.ctx.fillStyle = '#050505';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle";

                    // --- HEADER & HUD AS CANVAS RENDER ---
                    this.ctx.save();
                    const headerY = 40 + Math.sin(this.time * 2) * 2; // Breathing
                    this.ctx.shadowColor = "rgba(114, 222, 194, 0.5)";
                    this.ctx.shadowBlur = 10;
                    this.drawFloatingText("SHIELD / DOSSIER", 120, headerY, "#daa520", 18);
                    this.ctx.shadowBlur = 0;
                    this.drawFloatingText("CASE: HOM-990-26", 120, headerY + 15, "#888", 10);

                    // HUD Status (Bottom Right)
                    const hudX = this.canvas.width - 20;
                    const hudY = this.canvas.height - 120;
                    const hudBreath = Math.cos(this.time * 1.5) * 2;

                    this.ctx.textAlign = "right";
                    this.drawFloatingText(`POS: ${Math.floor(this.panX)}, ${Math.floor(this.panY)}`, hudX, hudY + hudBreath, "#888", 10);
                    this.drawFloatingText(`ZOOM: ${this.zoom.toFixed(2)}x`, hudX, hudY - 15 + hudBreath, "#72dec2", 10);
                    this.ctx.restore();

                    this.ctx.textAlign = "center"; // Reset for grid

                    // Physics Update
                    const ripples = engine.state.ripples;
                    for (let i = ripples.length - 1; i >= 0; i--) {
                        ripples[i].life++; ripples[i].radius += 0.15;
                        if (ripples[i].life > ripples[i].lifeMax) ripples.splice(i, 1);
                    }

                    // Agents Update
                    engine.state.activeAgents.forEach((agent, i) => {
                        if (agent.type === 'GARDENER' && Math.random() > 0.9) {
                            const dx = Math.floor(Math.random() * 3) - 1;
                            const dy = Math.floor(Math.random() * 3) - 1;
                            const nx = Math.max(0, Math.min(this.gridSize - 1, agent.x + dx));
                            const ny = Math.max(0, Math.min(this.gridSize - 1, agent.y + dy));
                            if (!this.gridState[ny][nx].color) {
                                this.gridState[ny][nx] = { char: 'o', color: agent.color };
                                agent.x = nx; agent.y = ny;
                            }
                        }
                    });

                    const size = this.gridSize;
                    const offset = size / 2;
                    const currentIsoW = this.baseIsoWidth * this.zoom;
                    const currentIsoH = this.baseIsoHeight * this.zoom;
                    const densityChars = "  ..,,--::;;==iiIIJJLLOO00##@@";

                    let closestCell = null;
                    let minDist = 1000;

                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            const rx = x - offset; const ry = y - offset;

                            let z = Math.sin((Math.sqrt(rx * rx + ry * ry) * 0.2) - this.time) * 5;
                            z += Math.sin(rx * 0.5) * Math.cos(ry * 0.5) * 3;

                            let activeColor = null;
                            let activeChar = null;
                            let isBang = false;

                            for (let r of ripples) {
                                const d = Math.abs(Math.sqrt((rx - r.x) ** 2 + (ry - r.y) ** 2) - r.radius);
                                if (d < 5) {
                                    const amp = Math.cos(d * 0.5) * r.strength;
                                    if (amp > 0) z += amp;
                                    if (d < 2 && amp > 5) {
                                        activeColor = r.color;
                                        if (r.text && r.text.length > 0) {
                                            const charIdx = (Math.abs(x + y) + Math.floor(this.time * 2)) % r.text.length;
                                            activeChar = r.text[charIdx];
                                            if (activeChar === '*') isBang = true;
                                        }
                                    }
                                    if (d < 0.5 && r.palette) {
                                        // Autonomous intersection thud for entities
                                        if (this.gridState[y][x].char && Math.random() > 0.99) {
                                            AudioEngine.thud(0.05, "B0");
                                        }
                                        const pIdx = (Math.abs(x * y) + Math.floor(r.radius)) % r.palette.length;
                                        this.gridState[y][x] = { char: r.palette[pIdx], color: r.color };
                                    }
                                }
                            }

                            const state = this.gridState[y][x];
                            if (state.char) {
                                if (!activeChar) activeChar = state.char;
                                if (!activeColor && state.color) activeColor = state.color;
                            }

                            if (this.selectedCells.has(`${x},${y}`)) activeColor = '#ffcc00';

                            const sx = this.cx + this.panX + (rx - ry) * currentIsoW;
                            const sy = this.cy + this.panY + (rx + ry) * currentIsoH - (z * 3 * this.zoom);

                            if (sx < -20 || sx > this.canvas.width + 20 || sy < -20 || sy > this.canvas.height + 20) continue;

                            if (this.mousePos) {
                                const dist = Math.hypot(sx - this.mousePos.x, sy - this.mousePos.y);
                                if (dist < 20 * this.zoom && dist < minDist) {
                                    minDist = dist;
                                    closestCell = { gridX: x, gridY: y, screenX: sx, screenY: sy, char: activeChar };
                                }
                            }

                            if (!activeChar) {
                                let index = Math.floor(z + 8);
                                index = Math.max(0, Math.min(index, densityChars.length - 1));
                                activeChar = densityChars[index];
                            }

                            // CONCENTRIC ZONE COLORING based on distance from center
                            const distFromCenter = Math.sqrt(rx * rx + ry * ry);
                            const maxDist = offset;
                            const zoneName = getZoneFromDistance(distFromCenter, maxDist);
                            const zoneColor = getZoneColor(zoneName);

                            // Zone boundary detection (draw brighter at ring edges)
                            const norm = distFromCenter / maxDist;
                            const isZoneBoundary = (
                                (norm > 0.11 && norm < 0.13) ||  // COSMOS edge
                                (norm > 0.29 && norm < 0.31) ||  // LITIGATION edge
                                (norm > 0.49 && norm < 0.51) ||  // LABOR edge
                                (norm > 0.74 && norm < 0.76)     // LIONS edge
                            );

                            if (activeColor) {
                                this.ctx.fillStyle = activeColor;
                                this.ctx.globalAlpha = 1.0;
                                const fontSize = Math.floor(Math.max(10, 14 * this.zoom));
                                this.ctx.font = `bold ${fontSize}px monospace`;
                                this.ctx.shadowBlur = isBang ? 10 * this.zoom : 0;
                                if (isBang) this.ctx.shadowColor = activeColor;
                            } else if (isZoneBoundary) {
                                // Draw zone boundaries with white/bright lines
                                this.ctx.fillStyle = '#ffffff';
                                this.ctx.globalAlpha = 0.6;
                                const fontSize = Math.floor(Math.max(6, 12 * this.zoom));
                                this.ctx.font = `bold ${fontSize}px monospace`;
                                this.ctx.shadowBlur = 0;
                                activeChar = 'Â·';
                            } else {
                                // Use zone color with height-based brightness
                                let brightness = 0.3 + (z / 20) * 0.4;
                                brightness = Math.max(0.15, Math.min(0.8, brightness));
                                this.ctx.fillStyle = zoneColor;
                                this.ctx.globalAlpha = brightness;
                                this.ctx.shadowBlur = 0;
                                const fontSize = Math.floor(Math.max(4, 11 * this.zoom));
                                this.ctx.font = `${fontSize}px monospace`;
                            }

                            this.ctx.fillText(activeChar, sx, sy);
                        }
                    }

                    this.hoverCell = closestCell;
                    if (this.hoverCell) {
                        // Draw Reticle
                        this.ctx.strokeStyle = '#fff'; this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(this.hoverCell.screenX - 8 * this.zoom, this.hoverCell.screenY - 8 * this.zoom, 16 * this.zoom, 16 * this.zoom);

                        // Tooltip logic
                        const tooltip = document.getElementById('tooltip');
                        if (this.hoverCell) {
                            tooltip.style.display = 'block';
                            let tx = this.mousePos ? this.mousePos.x + 15 : this.hoverCell.screenX + 15;
                            let ty = this.mousePos ? this.mousePos.y : this.hoverCell.screenY;
                            tooltip.style.left = tx + 'px';
                            tooltip.style.top = ty + 'px';
                            tooltip.innerText = `${this.hoverCell.gridX},${this.hoverCell.gridY} [${this.hoverCell.char}]`;
                        }
                    } else {
                        document.getElementById('tooltip').style.display = 'none';
                    }

                    this.drawMinimap();
                    this.ctx.globalAlpha = 1.0; this.ctx.shadowBlur = 0;

                } catch (e) { console.error(e); }
                requestAnimationFrame(() => this.loop());
            }
        }

        const engine = new RipplesEngine();
        const renderer = new HybridGridRenderer('viz-canvas');
    </script>
</body>

</html>