<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORCA x RIPPLES // AUTONOMIC</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --bg: #020202;
            --fg: #4af626;
            --dim: #1a5c0d;
            --gold: #ffcc00;
            --red: #ff3333;
            --cyan: #00ffff;
            --wave: #ffffff;
        }

        @font-face {
            font-family: 'Unscii';
            src: url('https://cdnjs.cloudflare.com/ajax/libs/unscii/1.0.0/unscii-16-full.ttf') format('truetype');
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Courier New', monospace;
            font-family: 'Unscii', monospace; 
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* CRT OVERLAY */
        #crt {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 99;
            opacity: 0.5;
            mix-blend-mode: overlay;
        }

        /* UI LAYOUT */
        #interface {
            display: grid;
            grid-template-columns: 1fr 320px;
            width: 95vw;
            height: 90vh;
            gap: 20px;
        }

        /* ORCA GRID */
        #grid-wrapper {
            position: relative;
            border: 1px solid var(--dim);
            overflow: hidden;
            background: #000;
            cursor: crosshair;
        }

        #grid-canvas { display: block; }

        /* INFO PANEL */
        aside {
            border-left: 1px solid var(--dim);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            font-size: 12px;
            line-height: 1.5;
            background: rgba(0, 20, 0, 0.1);
        }

        h1 { margin: 0; font-size: 16px; color: var(--fg); text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { color: var(--dim); margin-bottom: 10px; display: block; }

        .stat-block { border: 1px solid var(--dim); padding: 10px; }
        
        .active-mode { color: var(--fg); text-shadow: 0 0 5px var(--fg); }
        .inactive-mode { color: var(--dim); }

        .worldtext-log {
            flex-grow: 1;
            overflow-y: hidden;
            border-top: 1px dashed var(--dim);
            padding-top: 10px;
            font-size: 10px;
            color: var(--fg);
            display: flex;
            flex-direction: column-reverse; /* Bottom up */
        }

        .log-entry { margin-bottom: 6px; opacity: 0.8; animation: fadeSlide 0.3s ease-out; }
        @keyframes fadeSlide { from { opacity:0; transform:translateX(-10px); } to { opacity:0.8; transform:translateX(0); } }

        .log-G { color: var(--gold); }
        .log-O { color: var(--red); }
        .log-S { color: var(--cyan); }
        .log-SYS { color: #fff; font-weight: bold; border-bottom: 1px solid #333; padding-bottom: 2px; margin-bottom: 10px;}

    </style>
</head>
<body>

    <div id="crt"></div>

    <div id="interface">
        <div id="grid-wrapper">
            <canvas id="grid-canvas"></canvas>
        </div>

        <aside>
            <div>
                <h1>ORCA x RIPPLES</h1>
                <span class="subtitle">AUTONOMIC SYSTEM v1.5</span>
                
                <div class="stat-block">
                    <div>SCENARIO: <span id="scene-name" style="color:#fff">NULL</span></div>
                    <div>TICK: <span id="tick-disp">0000</span></div>
                    <div style="margin-top:10px;">
                        <span id="status-run" class="inactive-mode">● RUNNING</span> | 
                        <span id="status-mut" class="active-mode">≈ MUTATION</span>
                    </div>
                </div>
                
                <div style="margin-top: 15px; color: var(--dim); font-size: 10px;">
                    [SPACE] PLAY/PAUSE<br>
                    [R] RESET PERSPECTIVE<br>
                    [M] TOGGLE MUTATION<br>
                    [CLICK] INTERVENE
                </div>
            </div>

            <div class="worldtext-log" id="worldtext">
                <div class="log-entry">> SYSTEM HIBERNATING. PRESS SPACE.</div>
            </div>
        </aside>
    </div>

<script>
    /**
     * RIPPLES AUTONOMIC ENGINE
     * Self-playing cellular automata with scenario injection.
     */

    // --- CONFIG ---
    const COLS = 46;
    const ROWS = 28;
    const CHAR_W = 10;
    const CHAR_H = 18;
    
    // --- SCENARIOS (PERSPECTIVES) ---
    const SCENARIOS = [
        {
            id: 'CUPBOARD',
            entities: ['A', 'G'], // Ant, Glass
            density: 0.05,
            desc: "Domestic stillness. Ceramic topography."
        },
        {
            id: 'DEEP_FOREST',
            entities: ['W', 'M', 'S'], // Owl, Mycelium, Stone
            density: 0.08,
            desc: "Subterranean networks. Nocture geometry."
        },
        {
            id: 'URBAN_JUNGLE',
            entities: ['R', 'T', 'P'], // Rat, Traffic, Puddle
            density: 0.06,
            desc: "Concrete geology. Neon interference."
        }
    ];

    // --- STATE ---
    let grid = [];
    let nextGrid = [];
    let ripples = [];
    let tick = 0;
    let isPlaying = false;
    let mutationEnabled = true;
    let currentScenarioIdx = 0;
    
    // --- AUDIO ---
    const Audio = {
        synth: null,
        drone: null,
        crusher: null,
        ready: false,

        init: async () => {
            if(Audio.ready) return;
            await Tone.start();
            
            // PolySynth for Ripples
            Audio.synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 0.02, decay: 0.1, sustain: 0.1, release: 2 }
            }).toDestination();
            Audio.synth.volume.value = -12;

            // FX Chain
            Audio.crusher = new Tone.BitCrusher(4).toDestination();
            
            // Ambience
            Audio.drone = new Tone.Oscillator(100, "sine").toDestination();
            Audio.drone.volume.value = -30;
            Audio.drone.start();

            Audio.ready = true;
            log("AUDIO BUFFER ONLINE", "SYS");
        },

        trigger: (type, density) => {
            if(!Audio.ready) return;
            
            if(type === 'G') { // Goal (Harmonic)
                const notes = ["C4", "E4", "G4", "B4", "C5"];
                Audio.synth.triggerAttackRelease(notes[Math.floor(Math.random()*notes.length)], "8n");
            }
            if(type === 'O') { // Obstacle (Dissonant)
                Audio.synth.connect(Audio.crusher);
                Audio.synth.triggerAttackRelease("F#3", "32n");
                setTimeout(() => Audio.synth.disconnect(Audio.crusher).toDestination(), 100);
            }
            if(type === 'S') { // Shift (Modulation)
                Audio.drone.frequency.rampTo(Math.random() * 400 + 50, 2);
            }
            if(type === 'RESET') { // New Perspective
                const noise = new Tone.Noise("white").toDestination().start();
                noise.volume.value = -10;
                noise.stop("+0.2");
                Audio.drone.frequency.rampTo(100, 0.1);
            }
        }
    };

    // --- GRID LOGIC ---
    function initGrid(scenarioIdx = 0) {
        grid = new Array(ROWS * COLS).fill('.');
        ripples = [];
        
        const scene = SCENARIOS[scenarioIdx];
        document.getElementById('scene-name').innerText = scene.id;
        log(`PERSPECTIVE SHIFT: ${scene.id}`, "SYS");
        log(scene.desc, "SYS");

        // Procedural Generation
        let count = Math.floor((ROWS * COLS) * scene.density);
        while(count > 0) {
            let x = Math.floor(Math.random() * COLS);
            let y = Math.floor(Math.random() * ROWS);
            if(grid[y * COLS + x] === '.') {
                let ent = scene.entities[Math.floor(Math.random() * scene.entities.length)];
                grid[y * COLS + x] = ent;
                count--;
            }
        }
        
        // Seed initial ripples to start the chain
        spawnRipple(Math.floor(COLS/2), Math.floor(ROWS/2), 'G');
    }

    function shiftPerspective() {
        Audio.trigger('RESET');
        currentScenarioIdx = (currentScenarioIdx + 1) % SCENARIOS.length;
        // Flash Effect
        const cvs = document.getElementById('grid-canvas');
        cvs.style.filter = "invert(1)";
        setTimeout(() => cvs.style.filter = "invert(0)", 100);
        
        initGrid(currentScenarioIdx);
    }

    // --- RUNTIME ---
    function runTick() {
        tick++;
        document.getElementById('tick-disp').innerText = tick.toString().padStart(4, '0');
        nextGrid = [...grid];

        // 1. CLEAR VISUAL ARTIFACTS
        for(let i=0; i<nextGrid.length; i++) {
            if(nextGrid[i] === '~' || nextGrid[i] === '+' || nextGrid[i] === '░') {
                // Restore logic: if it was empty, make empty. 
                // Note: In a complex sim, we'd double buffer properly. 
                // Here we assume visual wave chars overwrite empty space.
                nextGrid[i] = '.';
            }
        }

        // 2. RANDOM MUTATION (The "Autonomic" part)
        if(mutationEnabled && Math.random() < 0.05) { // 5% chance per tick
            const x = Math.floor(Math.random() * COLS);
            const y = Math.floor(Math.random() * ROWS);
            const types = ['G', 'O', 'S'];
            spawnRipple(x, y, types[Math.floor(Math.random() * 3)]);
        }

        // 3. RIPPLE PHYSICS
        let activeRipples = [];
        ripples.forEach(r => {
            r.age++;
            
            // Draw expanding circle
            for (let y = -r.age; y <= r.age; y++) {
                for (let x = -r.age; x <= r.age; x++) {
                    let d2 = x*x + y*y;
                    // Circle Outline Logic
                    if (d2 <= r.age*r.age && d2 > (r.age-1)*(r.age-1)) {
                        let tx = r.x + x;
                        let ty = r.y + y;
                        if(tx >=0 && tx < COLS && ty >= 0 && ty < ROWS) {
                            let idx = ty * COLS + tx;
                            let cell = grid[idx];

                            // COLLISION LOGIC
                            if(cell !== '.' && !'~+░'.includes(cell)) {
                                // Hit an entity!
                                Audio.trigger(r.type);
                                if(Math.random() > 0.8) logCollision(cell, r.type);
                                
                                // Reaction: Entity flashes
                                nextGrid[idx] = '*'; // Bang
                            } else {
                                // Draw Wave
                                let waveChar = r.type === 'G' ? '+' : r.type === 'O' ? '░' : '~';
                                nextGrid[idx] = waveChar;
                            }
                        }
                    }
                }
            }

            if(r.age < r.max) activeRipples.push(r);
        });
        ripples = activeRipples;

        // 4. ENTITY CLEANUP (Remove bangs)
        for(let i=0; i<grid.length; i++) {
            if(grid[i] === '*') {
                // Restore entity? For now, we assume entities persist but bang visually.
                // To restore, we need an Entity Map. 
                // Simplified: The * stays for 1 tick then reverts to a random entity from scenario
                // creating a "Glitch" effect.
                const scene = SCENARIOS[currentScenarioIdx];
                nextGrid[i] = scene.entities[Math.floor(Math.random() * scene.entities.length)];
            }
        }

        grid = nextGrid;
        draw();
    }

    function spawnRipple(x, y, type) {
        ripples.push({x, y, type, age: 0, max: 12});
    }

    // --- VISUALIZATION ---
    const canvas = document.getElementById('grid-canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
        canvas.width = document.getElementById('grid-wrapper').offsetWidth;
        canvas.height = document.getElementById('grid-wrapper').offsetHeight;
    }
    window.addEventListener('resize', resize);
    setTimeout(resize, 100);

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = '16px Unscii, monospace';
        ctx.textBaseline = 'top';

        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                const char = grid[y * COLS + x];
                const px = x * CHAR_W + 15;
                const py = y * CHAR_H + 15;

                // Color Logic
                ctx.fillStyle = 'var(--dim)';
                
                if (char === '+') ctx.fillStyle = 'var(--gold)'; // Goal Wave
                else if (char === '░') ctx.fillStyle = 'var(--red)'; // Obstacle Wave
                else if (char === '~') ctx.fillStyle = 'var(--cyan)'; // Shift Wave
                else if (char === '*') { ctx.fillStyle = '#fff'; ctx.fillText('*', px, py); continue; }
                else if (char !== '.') ctx.fillStyle = '#fff'; // Entity

                if (char !== '.') ctx.fillText(char, px, py);
            }
        }
    }

    // --- LOGGING ---
    const NARRATIVE = {
        G: ["Desire vector aligned.", "Resource identified.", "Harmonic resonance achieved."],
        O: ["Friction detected.", "Path blocked.", "Dissonance in the lattice."],
        S: ["Phase shift.", "State transition.", "Entropy increased."]
    };

    function logCollision(char, type) {
        const msgs = NARRATIVE[type];
        const msg = msgs[Math.floor(Math.random() * msgs.length)];
        log(`[${char}] ${type} >> ${msg}`, type);
    }

    function log(text, type) {
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;
        div.innerText = `> ${text}`;
        const logContainer = document.getElementById('worldtext');
        logContainer.prepend(div);
        if(logContainer.children.length > 15) logContainer.lastChild.remove();
    }

    // --- CONTROLS ---
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') {
            e.preventDefault();
            isPlaying = !isPlaying;
            document.getElementById('status-run').className = isPlaying ? 'active-mode' : 'inactive-mode';
            if(isPlaying) Audio.init();
        }
        if(e.key.toUpperCase() === 'R') shiftPerspective();
        if(e.key.toUpperCase() === 'M') {
            mutationEnabled = !mutationEnabled;
            document.getElementById('status-mut').className = mutationEnabled ? 'active-mode' : 'inactive-mode';
        }
    });

    canvas.addEventListener('mousedown', (e) => {
        Audio.init();
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left - 15) / CHAR_W);
        const y = Math.floor((e.clientY - rect.top - 15) / CHAR_H);
        if(x>=0 && y>=0) spawnRipple(x, y, 'G');
    });

    // Boot
    initGrid(0);
    setInterval(() => {
        if(isPlaying) runTick();
    }, 120);

</script>
</body>
</html>